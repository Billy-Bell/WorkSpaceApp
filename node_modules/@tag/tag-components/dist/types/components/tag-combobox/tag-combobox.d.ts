import '../../stencil.core';
import { Accent, DataType, Icon } from '../../shared/types';
import { IComboFilterResult } from './tag-combobox.utils';
export declare class TagCombobox {
    /** The id of the input */
    id: string;
    /** The name of the input */
    name: string;
    /** Whether the component is disabled */
    disabled: boolean;
    /**
     * The data that drives the list
     */
    data: any[];
    /** The placeholder on the combobox */
    placeholder?: string;
    /** Whether the component should search for the value based on what the user has entered */
    doNotSuggest: boolean;
    /** The delay in milliseconds after the user stops typing before the filter is invoked */
    delay?: number;
    /** The selected value */
    value: any;
    /** The field in the data array prop that gives the value to show in the input */
    textField: string;
    /** The field in the data array prop that gives the actual value put in the value prop */
    valueField: string;
    /** The field in the data array prop that gives an image path */
    imageField: string;
    /** The left icon name. Use if the icon is the same for all list items */
    leftIcon: Icon;
    /** The field in the data array prop that gives an icon name for an icon on the left */
    leftIconField: string;
    /** The left icon size */
    leftIconSize: number;
    /** The left icon color */
    leftIconAccent: Accent;
    /** The right icon name. Use if the icon is the same for all list items */
    rightIcon: Icon;
    /** The field in the data array prop that gives an icon name for an icon on the right */
    rightIconField: string;
    /** The right icon size */
    rightIconSize: number;
    /** The right icon color */
    rightIconAccent: Accent;
    /** The field in the data array prop that gives the primary value */
    primaryField: string;
    /** Whether the primary field should be inline */
    primaryFieldInline?: boolean;
    /** The field in the data array prop that gives the secondary value */
    secondaryField?: string;
    /** An icon to appear next to the secondary field */
    secondaryFieldIcon?: Icon;
    /** The accent for the secondary icon */
    secondaryFieldIconAccent?: Accent;
    /** Whether the secondary field should be inline */
    secondaryFieldInline?: boolean;
    /** The label for left field 1 */
    leftLabel1?: string;
    /** The field in the data array prop that gives the value under the secondary value */
    leftField1?: string;
    /** An icon to appear next to the left field 1 */
    leftField1Icon?: Icon;
    /** The accent for the left field 1 icon */
    leftField1IconAccent?: Accent;
    /** Whether left field 1 should be inline */
    leftField1Inline?: boolean;
    /** The label for left field 2 */
    leftLabel2?: string;
    /** The field under leftField1 */
    leftField2?: string;
    /** An icon to appear next to the left field 2 */
    leftField2Icon?: Icon;
    /** The accent for the left field 2 icon */
    leftField2IconAccent?: Accent;
    /** Whether left field 2 should be inline */
    leftField2Inline?: boolean;
    /** The label for left field 3 */
    leftLabel3?: string;
    /** The field under leftField2 */
    leftField3?: string;
    /** An icon to appear next to the left field 3 */
    leftField3Icon?: Icon;
    /** The accent for the left field 3 icon */
    leftField3IconAccent?: Accent;
    /** Whether left field 3 should be inline */
    leftField3Inline?: boolean;
    /** The label for left field 4 */
    leftLabel4?: string;
    /** The field under leftField3 */
    leftField4?: string;
    /** An icon to appear next to the left field 4 */
    leftField4Icon?: Icon;
    /** The accent for the left field 1 icon */
    leftField4IconAccent?: Accent;
    /** Whether left field 4 should be inline */
    leftField4Inline?: boolean;
    /** The label for left field 5 */
    leftLabel5?: string;
    /** The field under leftField4 */
    leftField5?: string;
    /** An icon to appear next to the left field 5 */
    leftField5Icon?: Icon;
    /** The accent for the left field 5 icon */
    leftField5IconAccent?: Accent;
    /** Whether left field 5 should be inline */
    leftField5Inline?: boolean;
    /** The label for right field 1 */
    rightLabel1?: string;
    /** The field in the data array prop that appears at the right of the list */
    rightField1?: string;
    /** An icon to appear next to the right field 1 */
    rightField1Icon?: Icon;
    /** The accent for the right field 1 icon */
    rightField1IconAccent?: Accent;
    /** Whether right field 1 should be inline */
    rightField1Inline?: boolean;
    /** The label for right field 2 */
    rightLabel2?: string;
    /** The field under rightField1 */
    rightField2?: string;
    /** An icon to appear next to the right field 2 */
    rightField2Icon?: Icon;
    /** The accent for the right field 2 icon */
    rightField2IconAccent?: Accent;
    /** Whether right field 2 should be inline */
    rightField2Inline?: boolean;
    /** The label for right field 3 */
    rightLabel3?: string;
    /** The field under rightField2 */
    rightField3?: string;
    /** An icon to appear next to the right field 3 */
    rightField3Icon?: Icon;
    /** The accent for the right field 3 icon */
    rightField3IconAccent?: Accent;
    /** Whether right field 3 should be inline */
    rightField3Inline?: boolean;
    /** The label for right field 4 */
    rightLabel4?: string;
    /** The field under rightField3 */
    rightField4?: string;
    /** An icon to appear next to the right field 4 */
    rightField4Icon?: Icon;
    /** The accent for the right field 4 icon */
    rightField4IconAccent?: Accent;
    /** Whether right field 4 should be inline */
    rightField4Inline?: boolean;
    /** The label for right field 5 */
    rightLabel5?: string;
    /** The field under rightField4 */
    rightField5?: string;
    /** An icon to appear next to the right field 5 */
    rightField5Icon?: Icon;
    /** The accent for the right field 5 icon */
    rightField5IconAccent?: Accent;
    /** Whether right field 5 should be inline */
    rightField5Inline?: boolean;
    /** The primary field data type */
    primaryFieldType: DataType;
    /** The secondary field data type */
    secondaryFieldType?: DataType;
    /** The left field 1 field data type */
    leftField1Type?: DataType;
    /** The left field 2 field data type */
    leftField2Type?: DataType;
    /** The left field 3 field data type */
    leftField3Type?: DataType;
    /** The left field 4 field data type */
    leftField4Type?: DataType;
    /** The left field 5 field data type */
    leftField5Type?: DataType;
    /** The right field 1 field data type */
    rightField1Type?: DataType;
    /** The right field 2 field data type */
    rightField2Type?: DataType;
    /** The right field 3 field data type */
    rightField3Type?: DataType;
    /** The right field 4 field data type */
    rightField4Type?: DataType;
    /** The right field 5 field data type */
    rightField5Type?: DataType;
    /** JSX style object in JSON to apply to the primary field container */
    primaryFieldStyle: string;
    /** JSX style object in JSON to apply to the secondary field */
    secondaryFieldStyle?: string;
    /** JSX style object in JSON to apply */
    leftLabel1Style?: string;
    /** JSX style object in JSON to apply */
    leftLabel2Style?: string;
    /** JSX style object in JSON to apply */
    leftLabel3Style?: string;
    /** JSX style object in JSON to apply */
    leftLabel4Style?: string;
    /** JSX style object in JSON to apply */
    leftLabel5Style?: string;
    /** JSX style object in JSON to apply */
    rightLabel1Style?: string;
    /** JSX style object in JSON to apply */
    rightLabel2Style?: string;
    /** JSX style object in JSON to apply */
    rightLabel3Style?: string;
    /** JSX style object in JSON to apply */
    rightLabel4Style?: string;
    /** JSX style object in JSON to apply */
    rightLabel5Style?: string;
    /** JSX style object in JSON to apply */
    leftField1Style?: string;
    /** JSX style object in JSON to apply */
    leftField2Style?: string;
    /** JSX style object in JSON to apply */
    leftField3Style?: string;
    /** JSX style object in JSON to apply */
    leftField4Style?: string;
    /** JSX style object in JSON to apply */
    leftField5Style?: string;
    /** JSX style object in JSON to apply */
    rightField1Style?: string;
    /** JSX style object in JSON to apply */
    rightField2Style?: string;
    /** JSX style object in JSON to apply */
    rightField3Style?: string;
    /** JSX style object in JSON to apply */
    rightField4Style?: string;
    /** JSX style object in JSON to apply */
    rightField5Style?: string;
    /** JSX style object in JSON to apply */
    primaryFieldStyleField?: string;
    /** JSX style object in JSON to apply */
    secondaryFieldStyleField?: string;
    /** JSX style object in JSON to apply */
    leftField1StyleField?: string;
    /** JSX style object in JSON to apply */
    leftField2StyleField?: string;
    /** JSX style object in JSON to apply */
    leftField3StyleField?: string;
    /** JSX style object in JSON to apply */
    leftField4StyleField?: string;
    /** JSX style object in JSON to apply */
    leftField5StyleField?: string;
    /** JSX style object in JSON to apply */
    rightField1StyleField?: string;
    /** JSX style object in JSON to apply */
    rightField2StyleField?: string;
    /** JSX style object in JSON to apply */
    rightField3StyleField?: string;
    /** JSX style object in JSON to apply */
    rightField4StyleField?: string;
    /** JSX style object in JSON to apply */
    rightField5StyleField?: string;
    /**
     * The function to call to filter the data
     */
    filter: (criteria: string, data: any[]) => IComboFilterResult;
    /** Whether the input has a border */
    borderless?: boolean;
    /** Whether the input is disabled */
    inputDisabled?: boolean;
    /** The styles to apply to the input */
    inputStyle: string;
    /** The cursor position in the input */
    private textSelectionStart;
    private textSelectionEnd;
    /** Event raised when a field changes */
    private valueChange;
    /** The timer that is used to trigger the search when the user stops typing */
    private typingTimer;
    /** Reference to the root DOM element */
    private element;
    /** Whether the list is open */
    private listOpen;
    /** The filtered data */
    private filteredData;
    /** The value to show in the input */
    private text;
    /** The selected list item index */
    private listSelectedIndex;
    /** A flag to prevent the list being closed straight after it has opened when a user clicks the input */
    private disableInputClick;
    /** A flag to prevent the list being reopened straight after it has closed when a user clicks on a list item */
    private disableFocus;
    /**
     * Sets the focus to the combobox
     */
    focusInput(): void;
    /**
     * Selects the text in the input
     */
    select(): void;
    componentDidLoad(): void;
    componentDidUnload(): void;
    /** Set filteredData to data when data is first set */
    componentWillUpdate(): void;
    /** Selects the correct portion of the input text when it has just been updated */
    componentDidUpdate(): void;
    /**
     * This is a public method to set the data and paging information for this component.
     * If this component is used with a parent tag-http or tag-search component, the parent component
     * will call this method with the response data.
     * @param {IPagedData | any[]} data - The data which can be a simple array of objects or IPagedData
     */
    setData(data: any): void;
    setValue(value: any, suppressChangeEvent: boolean): void;
    render(): JSX.Element;
    private getInputContainerClass;
    /** Gets a reference to the input */
    private getInput;
    /** Gets a reference to the list */
    private getList;
    /**
     * Invokes the filter when the user stops typing
     * Selects the current item when the user presses Enter
     * Selects the next / previous item in the list when the arrow keys are pressed
     */
    private handleKeyUp;
    /**
     * Returns whether ALT is pressed
     * There is a try-catch wrapper is because e.getModifierState errors in unit tests
     */
    private isAltPressed;
    /** IE fix for their none standard key names */
    private ieFix;
    private closeList;
    /**
     * Handles Enter being pressed
     * This should select the current item in the list
     */
    private handleEnterPress;
    /**
     * Handles ALT+DOWN press
     * This should open the list
     */
    private handleAltDownPress;
    /**
     * Handles ESC press
     * This should close the list
     */
    private handleEscPress;
    /**
     * Handles Backspace press
     * This should close the list
     */
    private handleBackspacePress;
    /**
     * Handles DOWN press
     * This go to the next item in the list
     */
    private handleDownPress;
    /**
     * Handles UP press
     * This go to the previous item in the list
     */
    private handleUpPress;
    /**
     * Gets the data for key press logic
     * When the list is open we want the filtered data otherwise we want all the data
     */
    private getDataForKeyPress;
    /**
     * Handles user typing into the input
     * This should filter the list and predict the value but only if the do-not-suggest attribute is not set
     * @param {any} e - The keyboard event arg
     */
    private handleCharacterPress;
    private handleInputFocus;
    private handleInputClick;
    private handleDropDownArrowClick;
    private standardFilter;
    private getTextValueFromFilteredData;
    private handleListItemSelected;
    private selectItem;
    /**
     * Gets the value to render in the input
     * This may be the predicated value or the value being keyed in (if no match has occurred)
     */
    private getInputValueForRender;
    private getTextValueFromDataItem;
    private getValueFromDataItem;
    private getDataItemWithValue;
}
