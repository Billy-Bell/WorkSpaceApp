/**
 * Replaces variable references in a string with their real values
 * Variables are in {{}}
 * @param {string} text - The text that contains variable references
 * @param {any} context - An object containing the variable values
 */
export const variableReplacer = (text, context) => {
    if (context && text && text.length > 4 && text.indexOf('{{') >= 0 && text.indexOf('}}') >= 0) {
        const propFinder = /{{[A-Za-z0-9\-\_]+}}/gi;
        function replacer(match) {
            const propName = match.slice(2, -2);
            let item = match;
            if (context.hasOwnProperty(propName)) {
                item = context[propName];
                if (item === null || item === undefined) {
                    item = '';
                }
            }
            return item;
        }
        return text.replace(propFinder, replacer);
    }
    return text;
};
/**
 * Replaces variable references in a node and its child nodes
 * Variables are in {{}}
 * @param {Element} element - The element that contains variable references
 * @param {any} context - An object containing the variable values
 */
export const nodeVariableReplacer = (element, context) => {
    // tslint:disable-next-line:prefer-for-of
    for (let i = 0; i < element.childNodes.length; i++) {
        const node = element.childNodes[i];
        // go through attributes
        domAttributeVariableReplacer(node, context);
        // do the text content (if there aren't any children)
        domTextContentReplacer(node, context);
        // do all the child nodes
        nodeVariableReplacer(node, context);
    }
    // go through attribute on root element
    const ele = element;
    domAttributeVariableReplacer(ele, context);
    // do the text content on root element (if there aren't any children)
    domTextContentReplacer(element, context);
    return element;
};
/**
 * Replaces variable references in the text content of a DOM node
 * Variables are in {{}}
 * A safe copy of the binding expression is saved in a property called "bind"
 * @param {Element} element - The element that contains variable references
 * @param {any} context - An object containing the variable values
 */
export const domTextContentReplacer = (element, context) => {
    if (element.textContent && element.childNodes.length === 0) {
        let bindExpr = getSavedBindingExpressionFromElement(element);
        if (!bindExpr) {
            bindExpr = element.textContent;
        }
        const processedValue = variableReplacer(bindExpr, context);
        if (element.textContent !== processedValue) {
            saveBindingExpressionOnElement(element);
            element.textContent = processedValue;
        }
    }
};
/**
 * Saves the binding expression on the element for future renders
 * @param {Element} element - The element
 */
const saveBindingExpressionOnElement = (element) => {
    const elem = element;
    if (!elem.bind) {
        elem.bind = element.textContent;
    }
};
/**
 * Gets the saved binding expression
 * @param {Element} element - The element
 */
const getSavedBindingExpressionFromElement = (element) => {
    const elem = element;
    return elem.bind;
};
/**
 * Replaces variable references in attributes in a DOM node
 * Variables are in {{}}
 * A safe copy of the binding expression is saved in a property called "bind"
 * @param {HTMLElement} element - The element that contains variable references
 * @param {any} context - An object containing the variable values
 */
export const domAttributeVariableReplacer = (element, context) => {
    if (element.attributes && element.attributes.length) {
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < element.attributes.length; i++) {
            const attribute = element.attributes[i];
            let bindExpr = getSavedBindingExpressionFromAttribute(attribute);
            if (!bindExpr) {
                bindExpr = attribute.value;
            }
            const processedValue = variableReplacer(bindExpr, context);
            if (bindExpr !== processedValue) {
                saveBindingExpressionOnAttribute(attribute);
                element.setAttribute(attribute.name, processedValue);
            }
        }
    }
    return element;
};
/**
 * Saves the binding expression on attribute for future renders
 * @param {Attr} attribute - The attribute
 */
const saveBindingExpressionOnAttribute = (attribute) => {
    const att = attribute;
    if (!att.bind) {
        att.bind = attribute.value;
    }
};
/**
 * Gets the saved binding expression
 * @param {Attr} attribute - The attribute
 */
const getSavedBindingExpressionFromAttribute = (attribute) => {
    const att = attribute;
    return att.bind;
};
/** Sets the data in list item fields */
export const setElementFieldData = (itemFragment, itemIndex, data) => {
    const record = getRecord(itemIndex, data);
    const fieldNodes = itemFragment.querySelectorAll('tag-field');
    setFieldData(fieldNodes, record);
    const fieldEditNodes = itemFragment.querySelectorAll('tag-edit-field');
    setFieldData(fieldEditNodes, record);
};
/** Process field references in the template */
export const setElementFieldReferences = (itemFragment, itemIndex, data) => {
    const record = getRecord(itemIndex, data);
    const node = itemFragment;
    nodeVariableReplacer(node, record);
};
/* Returns a record at a given index */
const getRecord = (recordIndex, data) => {
    const record = data && data.length - 1 >= recordIndex ? data[recordIndex] : undefined;
    return record;
};
/**
 * Sets values on tag-field given a data record
 * @param {NodeListOf<HTMLTagFieldElement>} fieldNodes - The tag-fields
 * @param {any} data - The data record
 */
export const setFieldData = (fieldNodes, record) => {
    // tslint:disable-next-line:prefer-for-of
    for (let i = 0; i < fieldNodes.length; i++) {
        const field = fieldNodes[i];
        const fieldName = field.getAttribute('name');
        // set the field value
        const value = record === undefined ? undefined : record[fieldName];
        field.value = value;
        // evaluate any data bound attributes
        domAttributeVariableReplacer(field, record);
    }
};
/**
 * A reducer function that takes a list of vdom to reduce to and a list of nodes to parse
 * @param vdom reducer function previous parameter
 * @param node item to be parsed
 */
export function convertNodeToVdom(item, stylingElements) {
    function styleStringToObject(attrKey, attrVal) {
        if (attrKey.toLocaleLowerCase() === 'style') {
            const rules = attrVal.split(';');
            const styleObj = rules.reduce((styleObjBuilder, rule) => {
                const splitIndex = rule.indexOf(':');
                if (splitIndex !== -1) {
                    const ruleKey = rule.slice(0, splitIndex);
                    const ruleValue = rule.slice(splitIndex + 1);
                    styleObjBuilder[ruleKey.trim()] = ruleValue;
                }
                return styleObjBuilder;
            }, {});
            return styleObj;
        }
        return attrVal;
    }
    function isProcessedStyleElement(node) {
        if (node.nodeName === 'STYLE' || node.nodeName === 'LINK') {
            if (stylingElements.has(node)) {
                return true;
            }
            stylingElements.add(node);
            return false;
        }
        return false;
    }
    return function toVdom(vdom, node) {
        if (node.nodeName === 'TEMPLATE') {
            return vdom;
        }
        if (isProcessedStyleElement(node)) {
            return vdom;
        }
        let children = null;
        if (node.childNodes.length) {
            children = Array.from(node.childNodes).reduce(toVdom, []);
        }
        let a = {};
        if (node.nodeType === 1) {
            const el = node;
            const elAttrs = Array.from(el.attributes);
            a = elAttrs.reduce((data, elAttr) => {
                const val = styleStringToObject(elAttr.name, variableReplacer(elAttr.value, item));
                data[elAttr.name] = val;
                return data;
            }, {});
            if ((el.nodeName === 'TAG-FIELD' || el.nodeName === 'TAG-EDIT-FIELD') &&
                a.value === undefined) {
                a.value = item[a.name];
            }
            if (el.nodeName === 'TAG-POPOVER') {
                a.data = item;
            }
        }
        if (node.nodeName === '#text') {
            const text = variableReplacer(node.textContent, item);
            vdom.push(text);
        }
        if (node.nodeName === '#comment') {
            // ignore the element if a comment or we get an error down stream
            return vdom;
        }
        if (node.nodeName !== '#text') {
            vdom.push(h(node.nodeName, a, children));
        }
        return vdom;
    };
}
