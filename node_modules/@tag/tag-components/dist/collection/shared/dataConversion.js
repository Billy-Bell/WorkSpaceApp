/**
 * Converts a value as per the fields type
 * @param {string} value - The unconverted field value
 * @param {string} dataType - The type for the field
 * @param {string} locale - The locale
 */
export const valueConvertor = (value, dataType, locale = 'en-GB') => {
    let newValue;
    if (dataType && typeof value === 'string') {
        switch (dataType) {
            case 'date':
                newValue = parseDate(value, locale);
                break;
            case 'datetime':
                newValue = parseDateTime(value, locale);
                break;
            case 'integer':
                newValue = value === '' ? 0 : parseInt(value, 10);
                break;
            case 'currency':
            case 'decimal':
                newValue = value === '' ? 0 : parseFloat(value);
                break;
            case 'boolean':
                newValue = value.toLowerCase() === 'true' ? true : false;
                break;
            default:
                newValue = value;
        }
    }
    else {
        newValue = value;
    }
    return newValue;
};
export const currentLocale = navigator.language || 'en-GB';
const getCurrency = (locale) => {
    switch (locale.toLowerCase()) {
        case 'en-gb':
            return 'GBP';
        case 'en-us':
            return 'USD';
        default:
            return 'EUR';
    }
};
/**
 * formats a value as per the fields type
 * @param {string} value - The unformatted field value
 * @param {string} dataType - The type for the field
 * @param {any} options - Additional formatting options
 * @param {string} locale - The locale
 */
export const valueFormatter = (value, dataType, options, locale) => {
    locale = locale || currentLocale;
    const convertedValue = valueConvertor(value, dataType, locale);
    let formattedValue = value;
    if (dataType && value !== null && value !== undefined) {
        switch (dataType) {
            case 'date':
                formattedValue = convertedValue.toLocaleDateString(locale);
                break;
            case 'datetime':
                formattedValue =
                    convertedValue.toLocaleDateString(locale) +
                        ' ' +
                        convertedValue.toLocaleTimeString(locale);
                break;
            case 'decimal':
                if (!options) {
                    options = {
                        maximumFractionDigits: 10,
                        minimumFractionDigits: 0,
                    };
                }
                formattedValue = new Intl.NumberFormat(locale, options).format(convertedValue);
                break;
            case 'integer':
                if (!options) {
                    options = {
                        maximumFractionDigits: 0,
                        minimumFractionDigits: 0,
                    };
                }
                formattedValue = new Intl.NumberFormat(locale, options).format(convertedValue);
                break;
            case 'currency':
                if (!options) {
                    options = {
                        currency: getCurrency(locale),
                        minimumFractionDigits: 2,
                        style: 'currency',
                    };
                }
                formattedValue = new Intl.NumberFormat(locale, options).format(convertedValue);
                break;
            case 'boolean':
                formattedValue = convertedValue.toString();
                break;
            default:
                formattedValue = value;
        }
    }
    return formattedValue;
};
export const parseDate = (date, locale = 'en-GB') => {
    const separators = ['/', '\\', '-', '.'];
    let foundSeparator = false;
    let bits;
    separators.forEach(separator => {
        if (date.indexOf(separator) > -1) {
            foundSeparator = true;
            bits = date.split(separator);
        }
    });
    if (!foundSeparator || bits.length < 3) {
        return new Date(date);
    }
    if (locale.toLowerCase() === 'en-gb') {
        const day = parseInt(bits[0], 10);
        const month = mapMonthNameToNumber(bits[1]);
        const year = parseInt(bits[2], 10);
        const parsedDate = new Date(year, month - 1, day);
        return parsedDate;
    }
    else if (locale.toLowerCase() === 'en-us') {
        const day = parseInt(bits[1], 10);
        const month = mapMonthNameToNumber(bits[0]);
        const year = parseInt(bits[2], 10);
        const parsedDate = new Date(year, month - 1, day);
        return parsedDate;
    }
    return new Date(date);
};
export const parseDateTime = (dateTime, locale = 'en-GB') => {
    const separators = ['/', '\\', '-', '.'];
    let foundSeparator = false;
    let dateBits;
    separators.forEach(separator => {
        if (dateTime.indexOf(separator) > -1) {
            foundSeparator = true;
            dateBits = dateTime.split(separator);
        }
    });
    if (!foundSeparator || dateBits.length < 3) {
        return new Date(dateTime);
    }
    const timeString = dateTime.indexOf(' ') > -1 ? dateTime.split(' ')[1] : '';
    const timeBits = timeString ? timeString.split(':') : '';
    if (locale.toLowerCase() === 'en-gb') {
        const day = parseInt(dateBits[0], 10);
        const month = mapMonthNameToNumber(dateBits[1]);
        const year = parseInt(dateBits[2], 10);
        const hours = parseInt(timeBits.length >= 1 ? timeBits[0] : '0', 10);
        const mins = parseInt(timeBits.length >= 2 ? timeBits[1] : '0', 10);
        const secs = parseInt(timeBits.length >= 3 ? timeBits[2] : '0', 10);
        const parsedDate = new Date(year, month - 1, day, hours, mins, secs);
        return parsedDate;
    }
    else if (locale.toLowerCase() === 'en-us') {
        const day = parseInt(dateBits[1], 10);
        const month = mapMonthNameToNumber(dateBits[0]);
        const year = parseInt(dateBits[2], 10);
        const hours = parseInt(timeBits.length >= 1 ? timeBits[0] : '0', 10);
        const mins = parseInt(timeBits.length >= 2 ? timeBits[1] : '0', 10);
        const secs = parseInt(timeBits.length >= 3 ? timeBits[2] : '0', 10);
        const parsedDate = new Date(year, month - 1, day, hours, mins, secs);
        return parsedDate;
    }
    return new Date(dateTime);
};
const mapMonthNameToNumber = (monthName) => {
    if (monthName === undefined || monthName === null || monthName === '') {
        throw new Error("Invalid month name - can't be empty");
    }
    switch (monthName.toLowerCase()) {
        case 'jan':
        case 'january':
            return 1;
        case 'feb':
        case 'february':
            return 2;
        case 'mar':
        case 'march':
            return 3;
        case 'apr':
        case 'april':
            return 4;
        case 'may':
            return 5;
        case 'jun':
        case 'june':
            return 6;
        case 'jul':
        case 'july':
            return 7;
        case 'aug':
        case 'auguest':
            return 8;
        case 'sep':
        case 'sept':
        case 'september':
            return 9;
        case 'oct':
        case 'october':
            return 10;
        case 'nov':
        case 'november':
            return 11;
        case 'dec':
        case 'december':
            return 12;
        default:
            return parseInt(monthName, 10);
    }
};
