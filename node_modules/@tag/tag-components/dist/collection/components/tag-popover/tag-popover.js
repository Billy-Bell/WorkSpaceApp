import { getPositions } from './tag-popover.utils';
export class TagPopover {
    constructor() {
        /** Whether the popover is open */
        this.open = false;
        /** The colour of the arrow */
        this.arrowAccent = 'border';
        /** How the popover should be positioned */
        this.position = '';
        /** The left offset position of the arrow */
        this.arrowLeftOffset = 0;
        /** Whether the popup arrow should be hidden (it is when the popover has been pushed up form the bottom of the screen) */
        this.hideArrow = false;
        /** The arrow position direction */
        this.arrowPosition = 'top';
        /**
         * Handles click event on parent root element
         * Closes all popovers instances within the parent element including this one
         */
        this.handleParentRootClick = () => {
            const popovers = [].slice.call(this.parentElement.querySelectorAll('tag-popover'));
            popovers.forEach(popover => {
                popover.open = false;
            });
        };
        /**
         * Handles click event on the source element
         * Opens the popover
         */
        this.handleSourceClick = (e) => {
            e.stopPropagation();
            if (!this.suppressClick) {
                this.open = this.alwaysOpenWhenClick ? true : !this.open;
            }
        };
        /**
         * Handles keydown event on the source element
         * Opens the popover if Space or Enter are pressed
         */
        this.handleSourceKeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.stopPropagation();
                this.open = this.alwaysOpenWhenClick ? true : !this.open;
                // stop a click from firing on buttons straight after this
                this.suppressClick = true;
                setTimeout(() => {
                    this.suppressClick = false;
                }, 100);
            }
            if (e.key === 'Escape') {
                e.stopPropagation();
                this.open = false;
            }
        };
        /**
         * Closes the popover when ESC is pressed
         */
        this.handleKeyDown = (e) => {
            if (e.key === 'Escape') {
                this.closePopover();
            }
        };
    }
    clickHandler(evt) {
        evt.stopPropagation();
    }
    /**
     * Handles when the open property changes
     * If open is being set to true the popover is made visible and animated in to the users view
     * When a popover is being opened, other popovers are closed
     * If open is being set to false the popover is hidden and animated out of the users view
     * @param {boolean} newShow  - The new value of the open property
     * @param {boolean} currentShow  - The current value of the open property
     */
    openHandler(newShow, currentShow) {
        /** If the value hasn't changed, don't do anything */
        if (currentShow === newShow) {
            return;
        }
        if (newShow) {
            this.showPopover();
            this.opened.emit();
        }
        if (!newShow) {
            this.closePopover();
            this.closed.emit();
        }
    }
    /** Attach the popover to the source element when the component has loaded */
    componentDidLoad() {
        this.forElement = this.getSourceElement();
        this.parentElement = this.getParentRootElement();
        /**
         * Close all the other popovers
         * Add a click event listener to the root parent element
         * We attach a data-attached attribute the source element to ensure we only attach the listener once
         */
        if (this.parentElement) {
            if (this.parentElement.dataset.popoverListener !== 'attached') {
                this.parentElement.addEventListener('click', this.handleParentRootClick);
                this.parentElement.dataset.popoverListener = 'attached';
            }
        }
        /**
         * Add click handler to the source element
         * This will open the popover
         */
        if (this.forElement) {
            console.log('this.forElement', this.forElement);
            this.forElement.addEventListener('click', this.handleSourceClick);
            this.forElement.addEventListener('keydown', this.handleSourceKeydown);
        }
        /** on scroll we want to close the popover */
        document.onscroll = () => {
            this.closeAllOtherPopovers();
            this.closePopover();
        };
    }
    /** Remove any event handlers */
    componentDidUnload() {
        // remove the popover listener
        this.parentElement.dataset.popoverListener = null;
        this.parentElement.removeEventListener('click', this.handleParentRootClick);
        this.forElement.removeEventListener('click', this.handleSourceClick);
        this.forElement.removeEventListener('keydown', this.handleSourceKeydown);
    }
    render() {
        this.element.style.transform = `translate(${this.positionX}px, ${this.positionY}px)`;
        return (h("div", { class: "pop__container", onKeyDown: this.handleKeyDown },
            h("div", { class: "pop__containerinner" },
                !this.suppressCloseIcon && (h("tag-icon", { icon: "CrossThin", size: 21, class: "pop__close", onClick: () => (this.open = false) })),
                h("slot", null)),
            h("div", { class: this.getArrowClass(), style: {
                    left: `${this.arrowLeftOffset}px`,
                } })));
    }
    /** Returns the CSS class for the arrow */
    getArrowClass() {
        return this.hideArrow
            ? 'pop__arrow-hide'
            : `pop__arrow pop-arrow--${this.arrowPosition}--accent--${this.arrowAccent} pop__arrow--position-${this.arrowPosition}`;
    }
    /**
     * Gets the source element that opens the popover
     */
    getSourceElement() {
        /**
         * Gets an element given a CSS selector
         * @param {string} selector  - The CSS selector
         * @param {any} lookInElement  - The element to query for the CSS selector
         */
        function getSelector(selector, lookInElement) {
            const found = lookInElement.querySelector(selector);
            if (found) {
                return found;
            }
            if (lookInElement.parentElement) {
                return getSelector(selector, lookInElement.parentElement);
            }
            return;
        }
        const sourceElement = getSelector(this.popoverFor, this.element);
        return sourceElement;
    }
    /**
     * Gets the parent root element for the popover
     */
    getParentRootElement() {
        /**
         * Gets the parent root for an element
         * @param {any} element  - The element to get the parent root  for
         */
        function getParentRoot(element) {
            if (element.parentElement) {
                return getParentRoot(element.parentElement);
            }
            return element;
        }
        const parentRootElement = getParentRoot(this.element);
        return parentRootElement;
    }
    /**
     * Shows the popover and closes all other popover instances
     */
    showPopover() {
        this.closeAllOtherPopovers();
        /** Show the popover off the screen ready to animate in */
        const targetPos = this.forElement.getBoundingClientRect();
        this.element.style.transform = `translate(-5000px, -5000px)`;
        this.element.style.transitionDuration = '0ms';
        this.element.style.display = 'block';
        /** Animate the popover in */
        requestAnimationFrame(() => {
            const selfPos = this.element.getBoundingClientRect();
            const { arrowOffset, arrowPosition, lastPositionX, lastPositionY, firstPositionY, } = getPositions(targetPos, selfPos, window.innerHeight, window.innerWidth, this.position);
            this.closePosition = firstPositionY;
            this.arrowLeftOffset = arrowOffset;
            this.positionX = lastPositionX;
            this.element.style.transform = `translate(${this.positionX}px, ${firstPositionY}px)`;
            requestAnimationFrame(() => {
                /* Position element to final position */
                this.element.style.transitionDuration = '250ms';
                this.positionY = lastPositionY;
                this.arrowPosition = arrowPosition;
                this.element.style.opacity = '1';
            });
        });
    }
    /**
     * Closes the popover, animating it out
     */
    closePopover() {
        requestAnimationFrame(() => {
            this.positionY = this.closePosition;
            this.element.style.opacity = '0';
            // if we do not set to false the popup will not re-open when scrolled
            this.open = false;
            setTimeout(() => {
                this.element.style.display = 'none';
            }, 250);
        });
    }
    /**
     * Closes all other popover instances within the parent element
     */
    closeAllOtherPopovers() {
        const popovers = [].slice.call(this.parentElement.querySelectorAll('tag-popover'));
        popovers.forEach(popover => {
            if (popover !== this.element) {
                popover.open = false;
            }
        });
    }
    static get is() { return "tag-popover"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "alwaysOpenWhenClick": {
            "type": Boolean,
            "attr": "always-open-when-click"
        },
        "arrowAccent": {
            "type": String,
            "attr": "arrow-accent"
        },
        "arrowPosition": {
            "state": true
        },
        "element": {
            "elementRef": true
        },
        "forElement": {
            "state": true
        },
        "hideArrow": {
            "state": true
        },
        "open": {
            "type": Boolean,
            "attr": "open",
            "reflectToAttr": true,
            "mutable": true,
            "watchCallbacks": ["openHandler"]
        },
        "parentElement": {
            "state": true
        },
        "popoverFor": {
            "type": String,
            "attr": "popover-for"
        },
        "position": {
            "type": String,
            "attr": "position"
        },
        "positionX": {
            "state": true
        },
        "positionY": {
            "state": true
        },
        "suppressCloseIcon": {
            "type": Boolean,
            "attr": "suppress-close-icon"
        }
    }; }
    static get events() { return [{
            "name": "opened",
            "method": "opened",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "closed",
            "method": "closed",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "click",
            "method": "clickHandler"
        }]; }
    static get style() { return "/**style-placeholder:tag-popover:**/"; }
}
