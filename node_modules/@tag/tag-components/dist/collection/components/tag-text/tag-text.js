import { valueFormatter } from '../../shared/dataConversion';
import { createStyleFromJson } from '../../shared/utils';
export class TagText {
    constructor() {
        /** The type of the field that is used for value formatting */
        this.dataType = 'string';
    }
    render() {
        const { type, text, dataType } = this;
        const className = this.getClassName();
        const formattingOptionsObj = this.formattingOptions
            ? JSON.parse(this.formattingOptions)
            : undefined;
        let textValue = text;
        if (formattingOptionsObj) {
            textValue = valueFormatter(text, dataType, formattingOptionsObj);
        }
        {
            switch (type) {
                case 'h1':
                    return (h("h1", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'h2':
                    return (h("h2", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'h3':
                    return (h("h3", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'h4':
                    return (h("h4", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'h5':
                    return (h("h5", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'feature':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'small':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'label':
                    return (h("label", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'span':
                    return (h("span", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'default':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'min':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'kpi':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                case 'kpi-label':
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
                default:
                    return (h("p", { class: className, style: this.getStyle() },
                        textValue,
                        h("slot", null)));
            }
        }
    }
    getClassName() {
        let ret = '';
        if (this.type) {
            if (this.type.toLowerCase() === 'feature') {
                ret = 'feature';
            }
            else if (this.type.toLowerCase() === 'small') {
                ret = 'small';
            }
            else if (this.type.toLowerCase() === 'default') {
                ret = 'default';
            }
            else if (this.type.toLowerCase() === 'min') {
                ret = 'min';
            }
            else if (this.type.toLowerCase() === 'small') {
                ret = 'small';
            }
            else if (this.type.toLowerCase() === 'kpi') {
                ret = 'kpi';
            }
            else if (this.type.toLowerCase() === 'kpi-label') {
                ret = 'kpi-label';
            }
            else if (this.type.toLowerCase() === 'h1') {
                ret = 'h1';
            }
            else if (this.type.toLowerCase() === 'h2') {
                ret = 'h2';
            }
            else if (this.type.toLowerCase() === 'h3') {
                ret = 'h3';
            }
            else if (this.type.toLowerCase() === 'h4') {
                ret = 'h4';
            }
            else if (this.type.toLowerCase() === 'h5') {
                ret = 'h5';
            }
        }
        if (this.accent) {
            ret = ret ? `${ret} accent--${this.accent}` : `accent--${this.accent}`;
        }
        return ret;
    }
    getStyle() {
        const style = createStyleFromJson(this.textStyle);
        if (this.inline !== undefined) {
            style.display = this.inline === true ? 'inline-block' : 'block';
        }
        return style;
    }
    static get is() { return "tag-text"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "accent": {
            "type": String,
            "attr": "accent"
        },
        "dataType": {
            "type": String,
            "attr": "data-type",
            "mutable": true
        },
        "formattingOptions": {
            "type": String,
            "attr": "formatting-options"
        },
        "inline": {
            "type": Boolean,
            "attr": "inline"
        },
        "text": {
            "type": String,
            "attr": "text"
        },
        "textStyle": {
            "type": String,
            "attr": "text-style"
        },
        "type": {
            "type": String,
            "attr": "type"
        }
    }; }
    static get style() { return "/**style-placeholder:tag-text:**/"; }
}
