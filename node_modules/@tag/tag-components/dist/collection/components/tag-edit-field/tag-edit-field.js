var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { variableReplacer } from '../../shared/dataBinder';
import { valueConvertor, valueFormatter } from '../../shared/dataConversion';
import { createStyleFromJson } from '../../shared/utils';
import { convertTagValidationToObject, validateField, haveValueChangeValidation } from '../tag-validation/validation';
import { mapItems } from './tag-edit-field.utils';
/**
 * Encapsulates the rendering of a field including a label and a child component to render the value
 */
export class TagEditField {
    constructor() {
        /** The position of the label */
        this.labelPosition = 'top';
        /** The editor component that will be rendered */
        this.editor = 'textbox';
        /** The minimum value for a number or slider */
        this.min = 0;
        /** The maximum value for a number or slider */
        this.max = 100;
        /** The increment value for a number or slider */
        this.step = 1;
        /** The validation rule object which is set when the component is loaded from nested tag-validation elements */
        this.validationObj = [];
        /** The field validation errors  */
        this.errors = [];
        /** Whether the form has been successfully submitted */
        this.formSuccessfullySubmitted = false;
        /** Handles a change to a date picker */
        this.handleDatePickerValueChange = (e) => __awaiter(this, void 0, void 0, function* () {
            e.stopPropagation(); // stop the valueChange event getting raised twice
            this.internalSetValue(e.detail.value);
            yield this.validate();
        });
        /** Handles a change to file upload */
        this.handleFileChange = (e) => __awaiter(this, void 0, void 0, function* () {
            const files = e.detail.files;
            const file = files.length > 0 ? files[0] : undefined;
            this.internalSetValue(file);
            yield this.validate();
        });
        /** Handles a change to an input */
        this.handleInput = (e) => __awaiter(this, void 0, void 0, function* () {
            /* we need an additional check for max-length on input controls */
            if (this.maxLength && e.target.value.length > this.maxLength) {
                e.target.value = e.target.value.substring(0, this.maxLength);
            }
            this.internalSetValue(e.target.value);
            yield this.validate('valueChange');
        });
        /** Handles a change to an input */
        this.handleChange = (e) => __awaiter(this, void 0, void 0, function* () {
            this.internalSetValue(e.target.value);
        });
        /** Handles validation when blur is called on an input */
        this.handleBlur = () => __awaiter(this, void 0, void 0, function* () {
            const valueChange = haveValueChangeValidation(this.validationObj);
            yield this.validate(valueChange ? 'valueChange' : 'blur');
        });
        /** Handles a change to a checkbox */
        this.handleCheckboxChange = (e) => __awaiter(this, void 0, void 0, function* () {
            e.stopPropagation();
            this.internalSetValue(e.detail.value);
            yield this.validate();
        });
    }
    /** A public method to set the field validation errors */
    setErrors(errors) {
        this.errors = errors;
    }
    /**
     * Validates the value in the field
     */
    validate(executeOnly = 'blur') {
        return __awaiter(this, void 0, void 0, function* () {
            const form = this.getForm();
            let formValues = {};
            if (form) {
                formValues = Object.assign({}, form.getFieldValues(), { [this.name]: this.value });
            }
            else {
                formValues[this.name] = this.value;
            }
            const validationResult = yield validateField(this.name, this.validationObj, formValues, executeOnly);
            this.errors = validationResult.errors;
            // raise the validated event
            this.validated.emit({
                errors: this.errors,
                name: this.name,
            });
            return validationResult.errors;
        });
    }
    /** A public method to set the field value */
    setValue(value, suppressValidation, suppressChangeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            this.internalSetValue(value, suppressChangeEvent);
            if (!suppressValidation) {
                const errors = yield this.validate();
                return errors;
            }
            else {
                return [];
            }
        });
    }
    /**
     * This is a public method to set the data for the field items.
     * If this component is used with a parent tag-http component, tag-http
     * will call this method with the response data.
     */
    setData(data) {
        const sourceData = data.data ? data.data : data;
        this.itemsArr = mapItems(sourceData, this.defaultValue);
    }
    /** Sets default values for various properties when the component is loading */
    componentWillLoad() {
        this.setDataType(); // sorting the data type needs to come before setting defaults so that data conversion is correct
        this.setDefaultValue();
        this.setAllowSubmitOnReturn();
        this.rawValue = this.value;
    }
    /**
     * Sets the validation and drop down / radio options when the component had loaded
     * Note that doing this in componentWillLoad() causes unit tests to fail
     */
    componentDidLoad() {
        this.setValidationObject();
        this.setOptions();
    }
    /**
     * Sets the default value from the default value text attribute
     * Called from the form when all the other fields have been loaded and everything has been injected
     */
    setDefaultValue() {
        if (this.defaultValue !== undefined && this.value === undefined) {
            const newValue = variableReplacer(this.defaultValue, {
                today: new Date(),
            });
            this.internalSetValue(newValue, true);
        }
    }
    /**
     * Allows the form to sets the submit state
     */
    setFormSuccessfullySubmitted(value) {
        this.formSuccessfullySubmitted = value;
    }
    /**
     * Sets the focus to the editor
     */
    focusEditor() {
        if (this.editor) {
            const shadowRoot = this.element.shadowRoot ? this.element.shadowRoot : this.element;
            switch (this.editor.toLowerCase()) {
                case 'textbox':
                case 'password':
                case 'email':
                case 'number':
                    const input = shadowRoot.querySelector('input');
                    if (input) {
                        input.focus();
                    }
                    break;
                case 'multilinetextbox':
                    const textarea = shadowRoot.querySelector('textarea');
                    if (textarea) {
                        textarea.focus();
                    }
                    break;
                case 'checkbox':
                    const checkbox = shadowRoot.querySelector('tag-checkbox');
                    if (checkbox) {
                        checkbox.focusCheckbox();
                    }
                    break;
                case 'slider':
                    const slider = shadowRoot.querySelector('tag-slider');
                    if (slider) {
                        slider.focusSlider();
                    }
                    break;
                case 'dropdown':
                    const dropdown = shadowRoot.querySelector('select');
                    if (dropdown) {
                        dropdown.focus();
                    }
                    break;
                case 'radio':
                    const radio = shadowRoot.querySelector('input');
                    if (radio) {
                        radio.focus();
                    }
                    break;
                case 'combobox':
                    const combobox = shadowRoot.querySelector('tag-combobox');
                    if (combobox) {
                        combobox.focusInput();
                    }
                    break;
                case 'datepick':
                    const datepick = shadowRoot.querySelector('tag-date-picker');
                    if (datepick) {
                        datepick.focusInput();
                    }
                    break;
                case 'filepick':
                    const filepick = shadowRoot.querySelector('tag-file-picker');
                    if (filepick) {
                        filepick.focusButton();
                    }
                    break;
                default:
            }
        }
    }
    /**
     * Selects the text in the editor
     */
    selectEditorText() {
        if (this.editor) {
            const shadowRoot = this.element.shadowRoot ? this.element.shadowRoot : this.element;
            switch (this.editor.toLowerCase()) {
                case 'textbox':
                case 'password':
                case 'email':
                case 'number':
                    const input = shadowRoot.querySelector('input');
                    if (input) {
                        input.select();
                    }
                    break;
                case 'multilinetextbox':
                    const textarea = shadowRoot.querySelector('textarea');
                    if (textarea) {
                        textarea.select();
                    }
                    break;
                case 'combobox':
                    const combobox = shadowRoot.querySelector('tag-combobox');
                    if (combobox) {
                        combobox.select();
                    }
                    break;
                case 'datepick':
                    const datepick = shadowRoot.querySelector('tag-date-picker');
                    if (datepick) {
                        datepick.select();
                    }
                    break;
                default:
            }
        }
    }
    /**
     * A public method to allow the consumer to the validation rules for a field
     * @param {IFieldValidator[]} validation - An array of validation objects
     */
    setValidation(validation) {
        this.validationObj = validation;
    }
    render() {
        const { id, name, editor, label, placeholder, errors, value, rows, min, max, step, itemsArr, maxLength, } = this;
        const formattingOptionsObj = this.formattingOptions
            ? JSON.parse(this.formattingOptions)
            : undefined;
        const formattedValue = valueFormatter(this.value, this.dataType, formattingOptionsObj);
        const haveError = errors && errors.length > 0;
        const disabled = this.disabled || this.formSuccessfullySubmitted;
        // trim in case of max length
        let displayedValue = this.rawValue;
        if (typeof displayedValue === 'string' && maxLength) {
            displayedValue = displayedValue.substr(0, maxLength);
        }
        let displayedFormattedValue = formattedValue;
        if (typeof displayedFormattedValue === 'string' && maxLength) {
            displayedFormattedValue = displayedFormattedValue.substr(0, maxLength);
        }
        const containerStyle = createStyleFromJson(this.containerStyle);
        const labelStyle = createStyleFromJson(this.labelStyle);
        return (h("div", { class: this.getContainerClass(), style: containerStyle },
            label &&
                editor.toLowerCase() !== 'checkbox' && (h("label", { class: this.getLabelClass(), htmlFor: id, style: labelStyle }, label)),
            editor.toLowerCase() === 'textbox' && (h("input", { id: id, name: name, type: "text", class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), placeholder: placeholder, onInput: this.handleInput, onChange: this.handleChange, onBlur: this.handleBlur, value: disabled ? displayedFormattedValue : displayedValue, disabled: disabled, maxLength: maxLength })),
            editor.toLowerCase() === 'password' && (h("input", { id: id, name: name, type: "password", class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), placeholder: placeholder, onInput: this.handleInput, onChange: this.handleChange, value: displayedValue, onBlur: this.handleBlur, disabled: disabled, maxLength: maxLength })),
            editor.toLowerCase() === 'email' && (h("input", { id: id, name: name, type: "email", class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), placeholder: placeholder, onInput: this.handleInput, onChange: this.handleChange, onBlur: this.handleBlur, value: displayedValue, disabled: disabled, maxLength: maxLength })),
            editor.toLowerCase() === 'number' && (h("input", { id: id, name: name, type: disabled ? 'text' : 'number', class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), placeholder: placeholder, onClick: this.handleChange, onInput: this.handleInput, onChange: this.handleChange, onBlur: this.handleBlur, value: disabled ? displayedFormattedValue : displayedValue, max: max, min: min, step: step, disabled: disabled })),
            editor.toLowerCase() === 'multilinetextbox' && (h("textarea", { id: id, name: name, class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), placeholder: placeholder, onInput: this.handleInput, onChange: this.handleChange, onBlur: this.handleBlur, value: displayedValue, rows: rows, disabled: disabled, maxLength: maxLength })),
            editor.toLowerCase() === 'checkbox' && (h("tag-checkbox", { id: id, name: name, label: label, onValueChange: this.handleCheckboxChange, checked: value, disabled: disabled })),
            editor.toLowerCase() === 'slider' && (h("tag-slider", { id: id, name: name, style: createStyleFromJson(this.editorStyle), onValueChange: this.handleChange, value: displayedValue, disabled: disabled, min: min, max: max, dataType: 'decimal', step: step })),
            editor.toLowerCase() === 'dropdown' && (h("select", { id: id, name: name, class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), onChange: this.handleChange, disabled: disabled }, itemsArr &&
                itemsArr.map(item => (h("option", { value: item.value, selected: item.selected }, item.label))))),
            editor.toLowerCase() === 'radio' && (h("div", null, itemsArr &&
                itemsArr.map(item => (h("label", { class: "tag-edit-field__radiolabel" },
                    item.label,
                    h("input", { type: "radio", name: name, value: item.value, checked: item.selected, class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), onChange: this.handleChange, disabled: disabled }),
                    h("div", { class: "tag-edit-field__radiolabelcheck" })))))),
            editor.toLowerCase() === 'combobox' && (h("tag-combobox", { borderless: this.getInline(), inputDisabled: this.getInline(), id: id, name: name, placeholder: placeholder, class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), onValueChange: this.handleChange, value: displayedValue, disabled: disabled, data: itemsArr, textField: "label", valueField: "value" })),
            editor.toLowerCase() === 'datepick' && (h("tag-date-picker", { id: id, borderless: this.getInline(), inputDisabled: this.getInline(), class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), value: displayedValue, disabled: disabled, onValueChange: this.handleDatePickerValueChange, placeholder: placeholder })),
            editor.toLowerCase() === 'filepick' && (h("tag-file-picker", { id: id, class: this.getInputClass(), style: createStyleFromJson(this.editorStyle), disabled: disabled, onFileChange: this.handleFileChange, allowDragDrop: true })),
            haveError && (h("div", { class: this.getInline() ? 'tag-edit-field__error-text-inline' : 'tag-edit-field__error-text' }, errors.map(error => h("p", null, error))))));
    }
    /** Gets the CSS class for the container */
    getContainerClass() {
        const inline = this.getInline();
        const containerClass = inline
            ? 'tag-edit-field__container tag-edit-field__container-inline'
            : 'tag-edit-field__container';
        return containerClass;
    }
    /** Gets the CSS class for the label */
    getLabelClass() {
        const inline = this.getInline();
        const labelClass = inline
            ? this.editor.toLowerCase() === 'multilinetextbox'
                ? 'tag-edit-field__label tag-edit-field__label-inline-top'
                : 'tag-edit-field__label tag-edit-field__label-inline'
            : 'tag-edit-field__label';
        return labelClass;
    }
    /** Gets the CSS class for the input */
    getInputClass() {
        let inputClass = `tag-edit-field__${this.editor.toLowerCase()}`;
        const inline = this.getInline();
        if (inline) {
            inputClass = inputClass + ` tag-edit-field__${this.editor.toLowerCase()}-inline`;
        }
        const haveError = this.errors && this.errors.length > 0;
        if (haveError) {
            inputClass = inputClass + ' error';
        }
        return inputClass;
    }
    /** Gets the field is inline */
    getInline() {
        const labelPosition = this.getLabelPosition();
        const inline = this.inline || labelPosition.toLocaleLowerCase() === 'left';
        return inline;
    }
    /** Gets the field label position */
    getLabelPosition() {
        const labelPosition = this.labelPosition || 'top';
        return labelPosition;
    }
    /** Gets a reference to the parent form component */
    getForm() {
        let form = null;
        let el = this.element.parentElement;
        while (el && form === null) {
            if (el && el.tagName.toLowerCase() === 'tag-form') {
                form = el;
            }
            el = el.parentElement;
        }
        return form;
    }
    /** Sets the type if not set from the editor */
    setDataType() {
        if (!this.dataType) {
            switch (this.editor.toLowerCase()) {
                case 'checkbox':
                    this.dataType = 'boolean';
                    break;
                case 'number':
                    this.dataType = 'decimal';
                    break;
                case 'datepick':
                    this.dataType = 'date';
                    break;
                default:
                    this.dataType = 'string';
            }
        }
    }
    /** Sets the setAllowSubmitOnReturn property if not set from the editor */
    setAllowSubmitOnReturn() {
        this.allowSubmitOnReturn =
            this.allowSubmitOnReturn === undefined &&
                (this.editor === 'textbox' ||
                    this.editor === 'password' ||
                    this.editor === 'email' ||
                    this.editor === 'number');
    }
    /** Sets the field items to nested tag-edit-field-option elements */
    setOptions() {
        const options = [].slice.call(this.element.querySelectorAll('tag-edit-field-option'));
        if (options && options.length > 0) {
            const itemsArr = [];
            let selectedValue = null;
            options.forEach(option => {
                itemsArr.push({
                    label: option.textContent,
                    selected: option.selected,
                    value: option.value,
                });
                if (option.selected) {
                    selectedValue = option.value;
                }
            });
            this.itemsArr = itemsArr;
            if (selectedValue !== null) {
                this.internalSetValue(selectedValue, true);
            }
        }
    }
    /** Sets the selected values within the field items */
    setOptionsSelectValue(value) {
        if (this.itemsArr && this.itemsArr.length > 0) {
            this.itemsArr.forEach(option => {
                option.selected = option.value === value ? true : false;
            });
        }
    }
    /** Sets the validation object from the tag-validation child components */
    setValidationObject() {
        const validations = [].slice.call(this.element.querySelectorAll('tag-validation'));
        this.validationObj = convertTagValidationToObject(validations);
    }
    /** The list index if the field is part of a list */
    getListIndex() {
        const dataLi = this.element.getAttribute('data-li');
        const index = dataLi === undefined || dataLi === '' || dataLi === null ? undefined : parseInt(dataLi, 10);
        return index;
    }
    /**
     * A private central method for setting the field value,
     * doing any value conversion and raising the necessary events
     */
    internalSetValue(value, suppressChangeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            let convertedValue = valueConvertor(value, this.dataType);
            if (this.maxLength && typeof convertedValue === 'string') {
                convertedValue = convertedValue.substr(0, this.maxLength);
            }
            if (this.value !== convertedValue) {
                this.value = convertedValue;
                if (this.editor.toLowerCase() === 'radio') {
                    this.setOptionsSelectValue(this.value);
                }
                this.rawValue = value;
                // raise the change value event
                if (!suppressChangeEvent) {
                    this.valueChange.emit({
                        listIndex: this.getListIndex(),
                        name: this.name,
                        rawValue: value,
                        value: convertedValue,
                    });
                }
            }
        });
    }
    static get is() { return "tag-edit-field"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "allowSubmitOnReturn": {
            "type": Boolean,
            "attr": "allow-submit-on-return",
            "mutable": true
        },
        "containerStyle": {
            "type": String,
            "attr": "container-style"
        },
        "dataType": {
            "type": String,
            "attr": "data-type",
            "mutable": true
        },
        "defaultValue": {
            "type": String,
            "attr": "default-value"
        },
        "disabled": {
            "type": Boolean,
            "attr": "disabled"
        },
        "editor": {
            "type": String,
            "attr": "editor"
        },
        "editorStyle": {
            "type": String,
            "attr": "editor-style"
        },
        "element": {
            "elementRef": true
        },
        "errors": {
            "state": true
        },
        "focusEditor": {
            "method": true
        },
        "formattingOptions": {
            "type": String,
            "attr": "formatting-options"
        },
        "formSuccessfullySubmitted": {
            "state": true
        },
        "id": {
            "type": String,
            "attr": "id"
        },
        "inline": {
            "type": Boolean,
            "attr": "inline"
        },
        "itemsArr": {
            "state": true
        },
        "label": {
            "type": String,
            "attr": "label"
        },
        "labelPosition": {
            "type": String,
            "attr": "label-position"
        },
        "labelStyle": {
            "type": String,
            "attr": "label-style"
        },
        "max": {
            "type": Number,
            "attr": "max"
        },
        "maxLength": {
            "type": Number,
            "attr": "max-length"
        },
        "min": {
            "type": Number,
            "attr": "min"
        },
        "name": {
            "type": String,
            "attr": "name"
        },
        "placeholder": {
            "type": String,
            "attr": "placeholder"
        },
        "rows": {
            "type": Number,
            "attr": "rows"
        },
        "selectEditorText": {
            "method": true
        },
        "setData": {
            "method": true
        },
        "setDefaultValue": {
            "method": true
        },
        "setErrors": {
            "method": true
        },
        "setFormSuccessfullySubmitted": {
            "method": true
        },
        "setValidation": {
            "method": true
        },
        "setValue": {
            "method": true
        },
        "step": {
            "type": Number,
            "attr": "step"
        },
        "validate": {
            "method": true
        },
        "value": {
            "type": "Any",
            "attr": "value",
            "mutable": true
        }
    }; }
    static get events() { return [{
            "name": "valueChange",
            "method": "valueChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "validated",
            "method": "validated",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return "/**style-placeholder:tag-edit-field:**/"; }
}
