import { setElementFieldData, setElementFieldReferences } from '../../shared/dataBinder';
import { copy } from '../../shared/utils';
export class TagEditList {
    constructor() {
        /**
         * The class name for the list container.
         * Any utility class can be referenced
         */
        this.containerClassName = 'tag-edit-list';
    }
    /** Process the item template when the component loads */
    componentDidLoad() {
        this.processItemTemplate();
        const copiedData = copy(this.data);
        this.changedData = copiedData;
    }
    /** Process the item template when the component updates */
    componentDidUpdate() {
        this.processItemTemplate();
        if (!this.changedData) {
            const copiedData = copy(this.data);
            this.changedData = copiedData;
        }
    }
    /**
     * This is a public method to set the data for this component.
     * If this component is used with a parent tag-http, it will call this method with the response data.
     * @param {any[]} data - The data which can be a simple array of objects or IPagedData
     */
    setData(data) {
        this.data = data.data ? data.data : data;
    }
    /** Subscribe to field value change events and raises the listItemChanged event */
    changeHandler(e) {
        const args = e.detail;
        this.changedData[args.listIndex][args.name] = args.value;
        this.listItemChanged.emit({
            data: this.changedData,
            item: this.changedData[args.listIndex],
            itemIndex: args.listIndex,
            name: args.name,
            value: args.value,
        });
    }
    /**
     * This is a public method to set a field value.
     * This will push the value down to tag-edit-field
     * @param {IListItemSetValue} args - Contains the the field name, the value, the list item index and whether to suppress validation and the change events
     */
    setValue(args) {
        const { itemIndex, name, value, suppressChangeEvent, suppressValidation } = args;
        if (itemIndex < this.changedData.length) {
            this.changedData[itemIndex][name] = value;
            const LIs = this.getListItemNodes();
            const field = LIs[itemIndex].querySelector(`tag-edit-field[name='${name}']`);
            if (field) {
                field.setValue(value, suppressValidation, suppressChangeEvent);
            }
        }
        else {
            console.error('Error setting value, itemIndex does not exist');
        }
    }
    render() {
        return (h("div", { class: this.containerClassName },
            h("slot", { name: "header" }),
            h("ul", { style: {
                    height: this.height,
                    maxHeight: this.maxHeight,
                    minHeight: this.minHeight,
                } }, this.data && this.data.map(() => h("li", { class: this.itemContainerClassName }))),
            h("slot", { name: "footer" })));
    }
    processItemTemplate() {
        const template = this.element.querySelector('template');
        if (template) {
            const listitems = this.getListItemNodes();
            for (let i = 0; i < listitems.length; i++) {
                const clone = template.content.cloneNode(true);
                setElementFieldData(clone, i, this.data);
                setElementFieldReferences(clone, i, this.data);
                this.setElementFieldListIndexes(clone, i);
                const li = listitems[i];
                this.clearListItemChildren(li);
                li.appendChild(clone);
            }
        }
    }
    setElementFieldListIndexes(itemFragment, itemIndex) {
        const fieldNodes = itemFragment.querySelectorAll('tag-edit-field');
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < fieldNodes.length; i++) {
            const field = fieldNodes[i];
            field.setAttribute('data-li', itemIndex.toString());
            field.setAttribute('data-lname', this.name);
        }
    }
    /** Clears the content in a list item */
    clearListItemChildren(li) {
        while (li.firstChild) {
            li.removeChild(li.firstChild);
        }
    }
    /**
     * Gets the list item nodes.
     * When the app is running normally we get the items from shadowRoot.
     * When the unit tests are running we get the items element.
     */
    getListItemNodes() {
        const listitems = this.element.shadowRoot
            ? this.element.shadowRoot.querySelectorAll('ul li')
            : this.element.querySelectorAll('ul li');
        return listitems;
    }
    static get is() { return "tag-edit-list"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "containerClassName": {
            "type": String,
            "attr": "container-class-name"
        },
        "data": {
            "type": "Any",
            "attr": "data",
            "mutable": true
        },
        "element": {
            "elementRef": true
        },
        "height": {
            "type": String,
            "attr": "height"
        },
        "itemContainerClassName": {
            "type": String,
            "attr": "item-container-class-name"
        },
        "maxHeight": {
            "type": String,
            "attr": "max-height"
        },
        "minHeight": {
            "type": String,
            "attr": "min-height"
        },
        "name": {
            "type": String,
            "attr": "name"
        },
        "setData": {
            "method": true
        },
        "setValue": {
            "method": true
        }
    }; }
    static get events() { return [{
            "name": "listItemChanged",
            "method": "listItemChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "valueChange",
            "method": "changeHandler"
        }]; }
    static get style() { return "/**style-placeholder:tag-edit-list:**/"; }
}
