import { mapServerValidation } from '../tag-validation/validation';
// import { IChangeArgs } from "../tag-edit-field/tag-edit-field";
export class TagWizard {
    constructor() {
        /* The message displayed when the data has been successfully submitted **/
        this.submitSuccessMessage = 'The information was successfully saved!';
        /* The message displayed when an unexpected problem has occurred submitting the data **/
        this.submitFailureMessage = 'Sorry, an unexpected error has occurred';
        /* The message displayed when a validation problem has occurred submitting the data **/
        this.submitValidationMessage = 'Sorry, some of the information is invalid. Please review, adjust and try again';
        /**
         * A function that maps server validation errors to IFormErrors which is the format this component expects.
         * By default the ASP.NET MVC mapper is used
         */
        this.serverValidationMapper = mapServerValidation;
        /* The active step index **/
        this.activeStepIndex = 0;
    }
    // /** The values for each field in this wizard  */
    // private values: { [key: string]: any } = {};
    /** Gets the child tab components */
    componentDidLoad() {
        this.setHeightOnSteps();
        const firstStep = this.getCurrentStep();
        if (firstStep) {
            this.deactivateSteps();
            this.activateStep(firstStep);
        }
    }
    /** Go to the previous step when teh previous button is clicked */
    handlePreviousClick() {
        const previousStep = this.getPreviousStep();
        if (previousStep) {
            this.deactivateSteps();
            this.activateStep(previousStep);
            this.activeStepIndex--;
        }
    }
    /** Go to the next step when the next button is clicked */
    handleNextClick() {
        const nextStep = this.getNextStep();
        if (nextStep) {
            this.deactivateSteps();
            this.activateStep(nextStep);
            this.activeStepIndex++;
        }
    }
    /** Submit the data when finish is clicked */
    handleFinishClick() {
        const values = this.getFieldValues();
        this.submit.emit({ body: values });
    }
    /*
    * Allows the result of the submission to be pushed in this wizard.
    * This is used in the submission process to deal with the result of the submission.
    * tag-http will automatically call this method after the web api call if tag-http is used.
    */
    submitComplete(response) {
        /* Collect any server validation errors and map them to the form errors so they show against the correct field */
        if (response.status === 400) {
            const values = this.getFieldValues();
            let serverValidationErrors = {};
            Object.keys(values).forEach((key) => {
                serverValidationErrors[key] = [];
            });
            serverValidationErrors = this.serverValidationMapper(response, Object.keys(values));
            const fields = this.getFields();
            fields.forEach((element) => {
                const field = element;
                field.setErrors(serverValidationErrors[field.name]);
            });
        }
        /** Set the submit result so that the success / error information is shown to the user  */
        this.submitResult = {
            success: response.ok,
            validationError: response.status === 400,
        };
    }
    render() {
        return (h("div", null,
            h("slot", null),
            this.submitResult &&
                this.submitResult.success && (h("div", { class: "tag-wizard__alert-container" },
                h("tag-alert", { type: "information" }, this.submitSuccessMessage))),
            this.submitResult &&
                (this.submitResult.success === false && !this.submitResult.validationError) && (h("div", { class: "tag-wizard__alert-container" },
                h("tag-alert", { type: "danger" }, this.submitFailureMessage))),
            this.submitResult &&
                (this.submitResult.success === false && this.submitResult.validationError) && (h("div", { class: "tag-wizard__alert-container" },
                h("tag-alert", { type: "danger" }, this.submitValidationMessage)))));
    }
    /** Gets references to field DOM elements */
    getFields() {
        const fields = [].slice.call(this.element.querySelectorAll('tag-edit-field'));
        const editableLists = [].slice.call(this.element.querySelectorAll('tag-edit-list'));
        // get any fields in editable lists
        editableLists.forEach(list => {
            const listFields = [].slice.call(list.shadowRoot.querySelectorAll('tag-edit-field'));
            fields.push.apply(fields, listFields);
        });
        return fields;
    }
    getFieldValues() {
        const values = {};
        const fields = this.getFields();
        fields.forEach(field => {
            // if we have a list then collect the values in an array of objects under the list name
            const listName = field.getAttribute('data-lname');
            const listIndex = field.getAttribute('data-li');
            if (listName && listIndex) {
                const listIndexInt = parseInt(listIndex, 10);
                if (!values[listName]) {
                    values[listName] = [];
                }
                while (values[listName].length <= listIndexInt) {
                    values[listName].push({});
                }
                values[listName][listIndexInt][field.name] = field.value;
            }
            else {
                values[field.name] = field.value;
            }
        });
        return values;
    }
    /** Gets the previous step */
    getPreviousStep() {
        const steps = this.getSteps();
        let previousStep;
        const currentStep = this.getCurrentStep();
        if (currentStep) {
            if (currentStep.previousStep) {
                previousStep = this.getStep(currentStep.previousStep);
            }
            else {
                if (this.activeStepIndex - 1 >= 0) {
                    previousStep = steps[this.activeStepIndex - 1];
                }
            }
        }
        return previousStep;
    }
    /** Gets the next step */
    getNextStep() {
        const steps = this.getSteps();
        let nextStep;
        const currentStep = this.getCurrentStep();
        if (currentStep) {
            if (currentStep.nextStep) {
                nextStep = this.getStep(currentStep.nextStep);
            }
            else {
                if (this.activeStepIndex + 1 < steps.length) {
                    nextStep = steps[this.activeStepIndex + 1];
                }
            }
        }
        return nextStep;
    }
    /** Gets all the steps in this wizard */
    getSteps() {
        const steps = [].slice.call(this.element.querySelectorAll('tag-wizard-step'));
        return steps;
    }
    /** Gets the current step */
    getCurrentStep() {
        const steps = this.getSteps();
        let currentStep;
        if (this.activeStepIndex < steps.length) {
            currentStep = steps[this.activeStepIndex];
        }
        return currentStep;
    }
    /**
     * Get a step by its name
     * @param {string} name - the step name property
     */
    getStep(name) {
        const steps = this.getSteps();
        const foundSteps = steps.filter(step => step.name.toLowerCase() === name.toLowerCase());
        if (foundSteps.length > 0) {
            return foundSteps[0];
        }
        else {
            return undefined;
        }
    }
    /** Deactivates all the steps */
    deactivateSteps() {
        const steps = this.getSteps();
        steps.forEach(step => {
            step.style.display = 'none';
        });
    }
    /** Activates a step */
    activateStep(step) {
        step.style.display = 'block';
    }
    /** Sets the height on all the steps */
    setHeightOnSteps() {
        if (this.height) {
            // get the height integer value so that we can calculate what the content container height should be
            const heightInt = this.height && this.height.indexOf('px') === this.height.length - 2
                ? parseInt(this.height.substr(0, this.height.length - 2), 10)
                : undefined;
            const contentContainerHeight = heightInt ? `${heightInt - 60}px` : undefined;
            const steps = this.getSteps();
            steps.forEach(step => {
                // note that jest wit jsdom doesn't have a shadowRoot
                const stepContainer = step.shadowRoot
                    ? step.shadowRoot.querySelector('.tag-wizard-step')
                    : step.querySelector('.tag-wizard-step');
                if (stepContainer) {
                    stepContainer.style.height = this.height;
                }
                const stepContentContainer = step.shadowRoot
                    ? step.shadowRoot.querySelector('.tag-wizard-step__content-container')
                    : step.querySelector('.tag-wizard-step__content-container');
                if (stepContentContainer) {
                    stepContentContainer.style.maxHeight = contentContainerHeight;
                    stepContentContainer.style.height = contentContainerHeight;
                }
            });
        }
    }
    static get is() { return "tag-wizard"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "activeStepIndex": {
            "state": true
        },
        "element": {
            "elementRef": true
        },
        "height": {
            "type": String,
            "attr": "height"
        },
        "serverValidationMapper": {
            "type": "Any",
            "attr": "server-validation-mapper"
        },
        "submitComplete": {
            "method": true
        },
        "submitFailureMessage": {
            "type": String,
            "attr": "submit-failure-message"
        },
        "submitResult": {
            "state": true
        },
        "submitSuccessMessage": {
            "type": String,
            "attr": "submit-success-message"
        },
        "submitValidationMessage": {
            "type": String,
            "attr": "submit-validation-message"
        }
    }; }
    static get events() { return [{
            "name": "submit",
            "method": "submit",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "previousClick",
            "method": "handlePreviousClick"
        }, {
            "name": "nextClick",
            "method": "handleNextClick"
        }, {
            "name": "finishClick",
            "method": "handleFinishClick"
        }]; }
    static get style() { return "/**style-placeholder:tag-wizard:**/"; }
}
