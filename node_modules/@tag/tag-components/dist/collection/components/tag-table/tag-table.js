// tslint:disable-next-line:no-submodule-imports
import DataTable from 'carbon-components/umd/components/data-table-v2/data-table-v2.js';
import { valueFormatter } from '../../shared/dataConversion';
import { createStyleFromJson } from '../../shared/utils';
import { sort, sortStateMapper } from './sort-machine';
export class TagTable {
    constructor() {
        /** The data for the table */
        this.data = [];
        /** The current page number  */
        this.page = 1;
        /** The columns for the table */
        this.columns = [];
        /** JSX style object in JSON to apply */
        this.tableStyle = '';
        this.height = '';
        this.sortMap = sortStateMapper();
    }
    _handleSort(key) {
        const sorted = sort(this.sortMap.get(key), key, this.data);
        this.sortMap.set(key, sorted.state);
        this.data = [];
        this.data = sorted.data;
    }
    /**
     * This is a public method to set the data and paging information for this component.
     * If this component is used with a parent tag-http or tag-search component, the parent component
     * will call this method with the response data.
     * @param {IPagedData | any[]} data - The data which can be a simple array of objects or IPagedData
     */
    setData(data) {
        if (data.data) {
            this.setPagedData(data);
        }
        else {
            this.data = data;
        }
    }
    componentDidLoad() {
        const table = this.getTable();
        // tslint:disable-next-line:no-unused-expression
        new DataTable(table, {});
    }
    render() {
        const { data, page, pageSize, pageCount, tableStyle } = this;
        const columns = this.getColumns();
        const className = `bx--data-table-v2`;
        const containerStyle = !this.height ? {} : { height: this.height, overflow: 'auto' };
        const defaultRowStyle = !this.height ? {} : { position: 'relative' };
        const rowStyleField = createStyleFromJson(this.rowFieldStyle);
        const rowStyleObj = Object.assign({}, defaultRowStyle, rowStyleField);
        const startIndex = pageSize ? (page - 1) * pageSize + 1 : 0;
        const endIndex = data && data.length > 0 ? startIndex + data.length - 1 : 0;
        const pagerVisible = data && data.length > 0 && pageSize && endIndex >= pageSize;
        return (h("div", { class: "bx--data-table-v2-container", "data-table-v2": true, style: containerStyle },
            h("table", { class: className, style: createStyleFromJson(tableStyle) },
                h("thead", null,
                    h("tr", { style: rowStyleObj }, columns.map(column => this.getHeader(column)))),
                h("tbody", null, this.getRows(columns, data))),
            pagerVisible && h("tag-pager", { page: page, pageCount: pageCount })));
    }
    /**
     * Get the alignment columns and cells
     * @param {string} dataType  - The data type
     */
    getAlignment(dataType) {
        const alignMap = {
            boolean: 'center',
            button: 'center',
            currency: 'right',
            date: 'left',
            datetime: 'left',
            decimal: 'right',
            email: 'left',
            icon: 'center',
            image: 'center',
            integer: 'right',
            number: 'right',
            phonenumber: 'left',
            string: 'left',
        };
        return alignMap[dataType];
    }
    /**
     * Get the margin alignment for sortable columns    * @param {string} dataType  - The data type
     */
    getAlignmentMarginLeft(dataType) {
        const alignMap = {
            boolean: 'auto',
            button: 'auto',
            currency: 'auto',
            date: undefined,
            datetime: undefined,
            decimal: 'auto',
            email: undefined,
            icon: 'auto',
            image: 'auto',
            integer: 'auto',
            number: 'auto',
            phonenumber: undefined,
            string: undefined,
        };
        return alignMap[dataType];
    }
    /**
     * Get the margin alignment for sortable columns    * @param {string} dataType  - The data type
     */
    getAlignmentMarginRight(dataType) {
        const alignMap = {
            boolean: 'auto',
            button: 'auto',
            currency: undefined,
            date: undefined,
            datetime: undefined,
            decimal: undefined,
            email: undefined,
            icon: 'auto',
            image: 'auto',
            integer: undefined,
            number: undefined,
            phonenumber: undefined,
            string: undefined,
        };
        return alignMap[dataType];
    }
    getColumns() {
        let columns;
        if (this.columns.length > 0) {
            columns = this.columns;
        }
        else {
            columns = [].slice
                .call(this.element.querySelectorAll('tag-table-column'))
                .map((column) => {
                return {
                    caption: column.getAttribute('caption'),
                    cellAccentField: column.getAttribute('cell-accent-field'),
                    cellFieldStyle: column.getAttribute('cell-field-style'),
                    cellHeight: column.getAttribute('cell-height'),
                    cellWidth: column.getAttribute('cell-width'),
                    dataType: column.getAttribute('data-type'),
                    formattingOptionsObj: column.getAttribute('formatting-options')
                        ? JSON.parse(column.getAttribute('formatting-options'))
                        : undefined,
                    name: column.getAttribute('name'),
                    sortable: column.getAttribute('sortable') === '' ? true : false,
                };
            });
        }
        if (this.button) {
            columns.push({
                caption: '',
                dataType: 'button',
                name: '',
            });
        }
        return columns;
    }
    /**
     * Get the html for a column header
     * @param {IDataTableColumn} column  - The definition for the column
     */
    getHeader(column) {
        const align = this.getAlignment(column.dataType);
        const headerLabel = h("span", { class: "bx--table-header-label" }, column.caption);
        const columnClass = this.height === '' ? 'column static' : 'column sticky';
        const sortIcon = (h("svg", { class: "bx--table-sort-v2__icon", width: "10", height: "5", viewBox: "0 0 10 5", "fill-rule": "evenodd", style: { marginLeft: '3px', marginRight: '3px' } },
            h("path", { d: "M10 0L5 5 0 0z" })));
        return column.sortable ? (h("th", { class: columnClass },
            h("button", { class: "bx--table-sort-v2", "data-event": "sort", onClick: () => this._handleSort(column.name), style: {
                    marginLeft: this.getAlignmentMarginLeft(column.dataType),
                    marginRight: this.getAlignmentMarginRight(column.dataType),
                } },
                align === 'right' ? sortIcon : headerLabel,
                align === 'right' ? headerLabel : sortIcon))) : (h("th", { class: columnClass, style: { textAlign: align } }, column.caption));
    }
    /**
     * Get the html for the rows
     * @param {IDataTableColumn[]} columns  - The columns for the table
     * @param {any[]} data  - The data for the rows
     */
    getRows(columns, data) {
        return data.map(row => {
            let rowStyleObj = createStyleFromJson(this.rowFieldStyle);
            if (row.rowStyleField !== undefined && row.rowStyleField !== '') {
                const rowFieldStyleObj = createStyleFromJson(row.rowStyleField);
                rowStyleObj = Object.assign({}, rowStyleObj, rowFieldStyleObj);
            }
            return h("tr", { style: rowStyleObj }, columns.map(column => this.getCell(column, row)));
        });
    }
    /**
     * Get the html for the cell
     * @param {IDataTableColumn} column  - The column definition
     * @param {any} row  - The data row
     */
    getCell(column, row) {
        let inner;
        const value = row[column.name];
        const accent = column.cellAccentField
            ? row[column.cellAccentField]
                ? row[column.cellAccentField]
                : 'title'
            : 'title';
        const defaultCellStyleObj = {
            height: column.cellHeight,
            textAlign: this.getAlignment(column.dataType),
            verticalAlign: 'middle',
            width: column.cellWidth,
        };
        let cellFieldStyleObj = createStyleFromJson(column.cellFieldStyle);
        if (row.cellFieldStyle !== undefined && row.cellFieldStyle !== '') {
            const dataCellFieldStyleObj = createStyleFromJson(row.cellFieldStyle);
            cellFieldStyleObj = Object.assign({}, cellFieldStyleObj, dataCellFieldStyleObj);
        }
        const cellStyleObj = Object.assign({}, defaultCellStyleObj, cellFieldStyleObj);
        if (column.dataType === 'boolean') {
            inner =
                value === true ? h("tag-icon", { style: cellStyleObj, icon: "Checkbox", accent: accent }) : null;
        }
        else if (column.dataType === 'email') {
            const href = `mailto:${value}`;
            inner = value ? (h("tag-link", { style: cellStyleObj, text: value, href: href, target: "blank", accent: accent })) : null;
        }
        else if (column.dataType === 'phonenumber') {
            const href = `tel:${value}`;
            inner = value ? (h("tag-link", { style: cellStyleObj, text: value, href: href, target: "blank", accent: accent })) : null;
        }
        else if (column.dataType === 'image') {
            inner = value ? h("img", { src: value, style: cellStyleObj }) : null;
        }
        else if (column.dataType === 'icon') {
            inner = value ? h("tag-icon", { style: cellStyleObj, icon: value, accent: accent }) : null;
        }
        else if (column.dataType === 'button') {
            inner = (h("tag-button", { icon: this.buttonIcon, accent: this.buttonAccent, text: this.button, onButtonClick: e => this.handleButtonClick(e, row), style: cellStyleObj }));
        }
        else {
            inner = (h("tag-text", { style: cellStyleObj, type: "span", text: valueFormatter(value, column.dataType, column.formattingOptionsObj), accent: accent }));
        }
        return (h("td", { class: "cell", style: cellStyleObj }, inner));
    }
    /**
     * Set the data, page, pageSize and pageCount props from the IPagedData parameter
     * @param {IPagedData} pagedData  - The paged data
     */
    setPagedData(pagedData) {
        this.data = pagedData.data;
        if (pagedData.page) {
            this.page = pagedData.page;
        }
        if (pagedData.pageSize) {
            this.pageSize = pagedData.pageSize;
        }
        if (pagedData.pageCount) {
            this.pageCount = pagedData.pageCount;
        }
        else {
            if (this.data &&
                this.data.length > 0 &&
                this.pageSize &&
                this.data.length < pagedData.pageSize) {
                this.pageCount = this.page;
            }
        }
    }
    getTable() {
        return this.element.shadowRoot
            ? this.element.shadowRoot.querySelector('table')
            : this.element.querySelector('table');
    }
    /**
     * Handles the button click event
     * @param {any} e - The click event args
     * @param {any} row - The data for the row
     */
    handleButtonClick(e, row) {
        e.stopPropagation();
        const args = {
            row,
        };
        this.buttonClick.emit(args);
    }
    static get is() { return "tag-table"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "button": {
            "type": String,
            "attr": "button"
        },
        "buttonAccent": {
            "type": String,
            "attr": "button-accent"
        },
        "buttonIcon": {
            "type": String,
            "attr": "button-icon"
        },
        "columns": {
            "type": "Any",
            "attr": "columns"
        },
        "data": {
            "type": "Any",
            "attr": "data",
            "mutable": true
        },
        "element": {
            "elementRef": true
        },
        "height": {
            "type": String,
            "attr": "height"
        },
        "page": {
            "type": Number,
            "attr": "page",
            "mutable": true
        },
        "pageCount": {
            "type": Number,
            "attr": "page-count",
            "mutable": true
        },
        "pageSize": {
            "type": Number,
            "attr": "page-size",
            "mutable": true
        },
        "recordCount": {
            "type": Number,
            "attr": "record-count",
            "mutable": true
        },
        "rowFieldStyle": {
            "type": String,
            "attr": "row-field-style"
        },
        "setData": {
            "method": true
        },
        "sortMap": {
            "state": true
        },
        "tableStyle": {
            "type": String,
            "attr": "table-style"
        }
    }; }
    static get events() { return [{
            "name": "buttonClick",
            "method": "buttonClick",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "eventBeforeSort",
            "method": "_handleSort"
        }]; }
    static get style() { return "/**style-placeholder:tag-table:**/"; }
}
