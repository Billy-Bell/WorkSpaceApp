var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createStyleFromJson } from '../../shared/utils';
import { mapServerValidation } from '../tag-validation/validation';
export class TagForm {
    constructor() {
        /** The form type. By default this is a generic 'form'  */
        this.type = 'form';
        /* The text on the submit button **/
        this.submitButtonText = 'Submit';
        /* Control whether the submit button is disabled **/
        this.submitButtonDisabled = false;
        /* The message displayed when the data has been successfully submitted **/
        this.submitSuccessMessage = 'The information was successfully saved!';
        /* The message displayed when an unexpected problem has occurred submitting the data **/
        this.submitFailureMessage = 'Sorry, an unexpected error has occurred';
        /* The message displayed when a validation problem has occurred submitting the data **/
        this.submitValidationMessage = 'Sorry, some of the information is invalid. Please review, adjust and try again';
        /**
         * A function that can be called when the submission process starts to set any additional values.
         */
        this.submitStarting = this.emptySubmitStarting;
        /**
         * A function that maps server validation errors to IFormErrors which is the format this component expects.
         * By default the ASP.NET MVC mapper is used
         */
        this.serverValidationMapper = mapServerValidation;
        this.formStyle = '';
        /** The errors for each field in this form */
        this.errors = {};
        /** The state of a submit operation */
        this.submitState = { inProgress: false };
        /** The values for each field in this form  */
        this.values = {};
        /** Sets the default values on all the fields on the form */
        // public setFieldDefaultValues = (): void => {
        //   const fields = this.getFields();
        //   fields.forEach(field => {
        //     // TODO - check if field is loaded
        //     field.setDefaultValue();
        //   });
        // };
        /** Validates all the fields on the form */
        this.validateForm = () => __awaiter(this, void 0, void 0, function* () {
            const fields = this.getFields();
            yield Promise.all(fields.map((field) => __awaiter(this, void 0, void 0, function* () {
                const fieldErrors = yield field.validate();
                this.setError(field.name, fieldErrors);
            })));
            return !this.haveErrors();
        });
        /** Returns whether there are any validation errors on the form */
        this.haveErrors = () => {
            let haveError = false;
            Object.keys(this.errors).forEach((key) => {
                if (this.errors[key].length > 0) {
                    haveError = true;
                }
            });
            return haveError;
        };
        /** Handles a key press on the form */
        this.handleKeyPress = (e) => {
            /** Check to see if return is pressed on a single line field input and if so submit the form */
            const key = e.which || e.keyCode || 0;
            if (key === 13) {
                const field = e.target;
                if (field.allowSubmitOnReturn) {
                    this.handleSubmit();
                }
            }
        };
        /**
         * Handles the form submission
         * This may be handled manually by subscribing to the onSubmit event
         * When handled automatically, the form values will be posted to the specified http API endpoint
         */
        this.handleSubmit = (e) => __awaiter(this, void 0, void 0, function* () {
            /** Suppress the default submission behavior */
            if (e) {
                e.preventDefault();
            }
            /** If the submit button is disabled, return and do not submit */
            if (this.submitButtonDisabled) {
                return;
            }
            /**
             * Make sure we have got the latest values of any fields
             * First we grap native inputs and then tag-edit-fields
             * This is important if a field has been pre-filled in
             */
            const inputs = [].slice.call(this.element.querySelectorAll('input'));
            inputs.forEach(input => {
                if (input.name && input.value !== undefined) {
                    this.values[input.name] = input.value;
                }
            });
            const fields = this.getFields();
            fields.forEach((element) => {
                const field = element;
                if (field.value !== undefined) {
                    this.values[field.name] = field.value;
                }
            });
            const startingResult = yield this.submitStarting(this.values);
            if (startingResult.cancel) {
                return;
            }
            else {
                this.values = startingResult.values;
            }
            const isValid = yield this.validateForm();
            /** Make sure the form is valid */
            if (isValid) {
                /** Set the submit "inProgress" state to true so that the form is disabled  */
                this.submitState = Object.assign({}, this.submitState, { inProgress: true });
                this.submitButtonDisabled = true;
                /** Raise the submit event  */
                const body = Object.assign({ type: this.type }, this.values);
                this.submit.emit({ body });
            }
        });
    }
    watchHandler(newValue, oldValue) {
        // tslint:disable-next-line:prefer-conditional-expression
        if (newValue === true && oldValue === false) {
            this.submitState = Object.assign({}, this.submitState, { inProgress: true });
        }
        else {
            this.submitState = Object.assign({}, this.submitState, { inProgress: false });
        }
    }
    /** Public method to get the field values */
    getFieldValues() {
        return this.values;
    }
    /** Public method to get a field value */
    getFieldValue(fieldName) {
        return this.values[fieldName];
    }
    /** Public method to set field values */
    setFieldValues(values) {
        this.values = Object.assign({}, this.values, values);
    }
    /** Public method to set a field value */
    setFieldValue(fieldName, value) {
        const newFieldValue = { [fieldName]: value };
        this.values = Object.assign({}, this.values, newFieldValue);
    }
    /** Public method to set a validation error */
    setError(fieldName, errors) {
        this.errors = Object.assign({}, this.errors, { [fieldName]: errors });
    }
    /** Subscribe to field value change events  */
    changeHandler(e) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = e.detail;
            this.setFieldValue(args.name, args.value);
        });
    }
    /** Subscribe to field validated events  */
    validatedHandler(e) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = e.detail;
            this.setError(args.name, args.errors);
        });
    }
    /*
    * Allows the result of the submission to be pushed in this form.
    * This is used in the form submit process to deal with the result of the submission.
    * tag-http will automatically call this method after the web api call if tag-http is used.
    */
    submitComplete(response) {
        /* Collect any server validation errors and map them to the form errors so they show against the correct field */
        let serverValidationErrors = {};
        Object.keys(this.values).forEach((key) => {
            serverValidationErrors[key] = [];
        });
        if (response.status === 400) {
            serverValidationErrors = this.serverValidationMapper(response, Object.keys(this.values));
        }
        /** Set the submit state so that the success / error information is shown to the user  */
        this.submitState = Object.assign({}, this.submitState, { inProgress: false, result: {
                success: response.ok,
                validationError: response.status === 400,
            } });
        this.errors = serverValidationErrors;
        /** Push any field validation errors and submit state down to fields  */
        const fields = this.getFields();
        fields.forEach((element) => {
            const field = element;
            field.setErrors(this.errors[field.name]);
            field.setFormSuccessfullySubmitted(this.submitState.result.success);
        });
    }
    render() {
        return (h("form", { style: createStyleFromJson(this.formStyle), onSubmit: this.handleSubmit, onKeyPress: this.handleKeyPress, novalidate: true, class: this.inline ? 'tag-form-inline' : 'tag-form' },
            h("slot", null),
            h("tag-form-group", { inline: this.inline, borderless: this.inline },
                h("tag-button", { type: "submit", icon: this.submitButtonIcon, "icon-accent": this.submitButtonIconAccent, accent: this.submitButtonAccent, disabled: this.haveErrors() || this.submitState.inProgress || this.submitButtonDisabled, onButtonClick: this.handleSubmit, text: this.submitButtonText })),
            this.submitState.result &&
                this.submitState.result.success && (h("tag-form-group", { inline: this.inline, borderless: this.inline },
                h("tag-alert", { type: "information" }, this.submitSuccessMessage))),
            this.submitState.result &&
                (this.submitState.result.success === false &&
                    !this.submitState.result.validationError) && (h("tag-form-group", { inline: this.inline, borderless: this.inline },
                h("tag-alert", { type: "danger" }, this.submitFailureMessage))),
            this.submitState.result &&
                (this.submitState.result.success === false &&
                    this.submitState.result.validationError) && (h("tag-form-group", { inline: this.inline, borderless: this.inline },
                h("tag-alert", { type: "danger" }, this.submitValidationMessage)))));
    }
    /** Set any field default values and request field items after the component has loaded */
    // public componentDidLoad() {
    //   this.setFieldDefaultValues();
    // }
    /** Gets references to field DOM elements */
    getFields() {
        const fields = [].slice.call(this.element.querySelectorAll('tag-edit-field'));
        return fields;
    }
    emptySubmitStarting(values) {
        return __awaiter(this, void 0, void 0, function* () {
            return { values, cancel: false };
        });
    }
    static get is() { return "tag-form"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "element": {
            "elementRef": true
        },
        "errors": {
            "state": true
        },
        "formStyle": {
            "type": String,
            "attr": "form-style"
        },
        "getFieldValue": {
            "method": true
        },
        "getFieldValues": {
            "method": true
        },
        "inline": {
            "type": Boolean,
            "attr": "inline"
        },
        "serverValidationMapper": {
            "type": "Any",
            "attr": "server-validation-mapper"
        },
        "setError": {
            "method": true
        },
        "setFieldValue": {
            "method": true
        },
        "setFieldValues": {
            "method": true
        },
        "submitButtonAccent": {
            "type": String,
            "attr": "submit-button-accent"
        },
        "submitButtonDisabled": {
            "type": Boolean,
            "attr": "submit-button-disabled",
            "mutable": true,
            "watchCallbacks": ["watchHandler"]
        },
        "submitButtonIcon": {
            "type": String,
            "attr": "submit-button-icon"
        },
        "submitButtonIconAccent": {
            "type": String,
            "attr": "submit-button-icon-accent"
        },
        "submitButtonText": {
            "type": String,
            "attr": "submit-button-text"
        },
        "submitComplete": {
            "method": true
        },
        "submitFailureMessage": {
            "type": String,
            "attr": "submit-failure-message"
        },
        "submitStarting": {
            "type": "Any",
            "attr": "submit-starting"
        },
        "submitState": {
            "state": true
        },
        "submitSuccessMessage": {
            "type": String,
            "attr": "submit-success-message"
        },
        "submitValidationMessage": {
            "type": String,
            "attr": "submit-validation-message"
        },
        "type": {
            "type": String,
            "attr": "type"
        }
    }; }
    static get events() { return [{
            "name": "submit",
            "method": "submit",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "valueChange",
            "method": "changeHandler"
        }, {
            "name": "validated",
            "method": "validatedHandler"
        }]; }
    static get style() { return "/**style-placeholder:tag-form:**/"; }
}
