var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { valueConvertor } from '../../shared/dataConversion';
import { httpCall } from '../../shared/http';
/**
 * Converts a tag-validation elements to an array of IFieldValidator objects
 * @param {HTMLTagValidationElement[]} validationTags - The tag-validation elements
 * @returns {IFieldValidator[]} An array of the validation rules in object format
 */
export const convertTagValidationToObject = (validationTags) => {
    if (validationTags && validationTags.length > 0) {
        const validationObj = validationTags.map(validation => {
            const fieldValidator = {
                args: convertArgs(validation.args, validation.rule),
                executeOn: validation.executeOn,
                message: validation.message ? validation.message : validation.textContent.trim(),
                rule: mapRuleStringToFunction(validation.rule),
            };
            return fieldValidator;
        });
        return validationObj;
    }
    else {
        return [];
    }
};
/**
 * maps a string to a validator function
 * @param {string} rule - The validation rule in string format
 */
const mapRuleStringToFunction = (rule) => {
    switch (rule.toLowerCase()) {
        case 'required':
            return required;
        case 'email':
        case 'isemail':
            return isEmail;
        case 'url':
        case 'isurl':
            return isUrl;
        case 'maxlength':
            return maxLength;
        case 'minlength':
            return minLength;
        case 'inarray':
            return inArray;
        case 'notinarray':
            return notInArray;
        case 'matches':
            return matches;
        case 'greaterthan':
            return greaterThan;
        case 'greaterthanorequalto':
            return greaterThanOrEqualTo;
        case 'lessthan':
            return lessThan;
        case 'lessthanorequalto':
            return lessThanOrEqualTo;
        case 'inhttpresponse':
            return inHttpResponse;
        case 'notinhttpresponse':
            return notInHttpResponse;
        default:
            if (window[rule]) {
                return window[rule];
            }
            else {
                return undefined;
            }
    }
};
/**
 * converts the args from string to the correct type
 * @param {any} args - The args. The data type may be explicitly by supplying xx|DataType
 * @param {string} rule - The validation rule
 */
const convertArgs = (args, rule) => {
    if (args && typeof args === 'string') {
        const dataTypeAndValue = extractDataTypeFromArgs(args);
        if (rule.toLowerCase() === 'maxlength' || rule.toLowerCase() === 'minlength') {
            dataTypeAndValue.dataType = 'integer';
        }
        if (rule.toLowerCase() === 'inarray' ||
            rule.toLowerCase() === 'notinarray' ||
            rule.toLowerCase() === 'inhttpresponse' ||
            rule.toLowerCase() === 'notinhttpresponse') {
            dataTypeAndValue.value = JSON.parse(args);
        }
        return valueConvertor(dataTypeAndValue.value, dataTypeAndValue.dataType);
    }
    else {
        return args;
    }
};
/**
 * converts the args from string to the correct type
 * @param {any} args - The args
 * @returns {IDataTypeAndValue} - The data type and value
 */
const extractDataTypeFromArgs = (args) => {
    const result = {
        dataType: 'string',
        value: args,
    };
    if (args && typeof args === 'string' && args.indexOf('|') > 0) {
        const pipePosn = args.indexOf('|');
        result.dataType = args.substring(pipePosn + 1);
        result.value = args.substring(0, pipePosn);
    }
    return result;
};
/**
 * Validates a field
 * @param {string} fieldName - The field name
 * @param {IFieldValidator[]} validations - The validation rules to apply
 * @param {IFormValues} values - All the values on the form
 * @returns {Promise<IValidateFieldResult>} - The result of the validation check
 */
export const validateField = (fieldName, validations, values, executeOnly = 'blur') => __awaiter(this, void 0, void 0, function* () {
    const result = { valid: true, errors: [] };
    if (validations && validations.length > 0) {
        yield Promise.all(validations.map((validation) => __awaiter(this, void 0, void 0, function* () {
            if (validation && validation.rule) {
                if (validation.executeOn === executeOnly) {
                    const newError = yield validation.rule(values, fieldName, validation.args);
                    if (newError) {
                        result.valid = false;
                        result.errors.push(validation.message ? validation.message : newError);
                    }
                }
            }
        })));
    }
    return result;
});
/**
 * Checks whether there are any validation rules that need to execute when the value is changed
 * @param {IFieldValidator[]} validations - The validation rules to check
 * @returns {boolean} - Whether there are validation rules that need to execute when the value is changed
 */
export const haveValueChangeValidation = (validations) => {
    let found = false;
    if (validations && validations.length > 0) {
        validations.forEach(validation => {
            if (validation && validation.rule) {
                if (validation.executeOn && validation.executeOn.toLowerCase() === 'valuechange') {
                    found = true;
                }
            }
        });
    }
    return found;
};
const convertToCamelCase = (text) => {
    let result = text;
    if (result) {
        result = result.charAt(0).toLowerCase() + result.substring(1);
    }
    return result;
};
const convertServerErrorsCamelCase = (errors) => {
    const build = {};
    if (errors) {
        Object.keys(errors).forEach((key) => {
            const newKey = convertToCamelCase(key);
            build[newKey] = errors[key];
        });
    }
    return build;
};
/**
 * Maps an ASP.NET server validation error object (IServerErrors) to our errors object (IFormErrors)
 * @param {response} errors - The full http response
 * @param {string[]} fieldNames - The field names on the form
 */
export const mapServerValidation = (response, fieldNames) => {
    const errors = response && response.body;
    const build = ({} = convertServerErrorsCamelCase(errors));
    fieldNames.forEach(fieldName => {
        if (!build[fieldName]) {
            build[fieldName] = [];
        }
    });
    return build;
};
const isBlank = (value) => value === null || value === undefined || value === '';
/**
 * Validates that the value has been populated
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const required = (values, fieldName) => isBlank(values[fieldName]) ? 'This must be populated' : '';
/**
 * Validates that the value is a correctly formatted email
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const isEmail = (values, fieldName) => !isBlank(values[fieldName]) &&
    values[fieldName].search(/^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/) === -1
    ? 'This must be in a valid email format'
    : '';
/**
 * Validates that the value is a correctly formatted URL
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const isUrl = (values, fieldName) => !isBlank(values[fieldName]) && values[fieldName].search(new RegExp('^(http|https)://', 'i'))
    ? 'This must be in a valid URL format'
    : '';
/**
 * Validates that the value hasn't exceeded a certain amount of characters
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {number} length - The length to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const maxLength = (values, fieldName, length) => !isBlank(values[fieldName]) && values[fieldName].length > length
    ? `This can not exceed ${length} characters`
    : '';
/**
 * Validates that the value is at least a certain amount of characters
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {number} length - The length to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const minLength = (values, fieldName, length) => values[fieldName].length < length ? `This must be at least ${length} characters` : '';
/**
 * Validates that the value is in an array
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any[]} array - The array to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const inArray = (values, fieldName, array) => array.indexOf(values[fieldName]) === -1 ? `This is not a valid value` : '';
/**
 * Validates that the value is not in an array
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any[]} array - The array to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const notInArray = (values, fieldName, array) => array.indexOf(values[fieldName]) > -1 ? `This is not a valid value` : '';
/**
 * Validates that the value matches the specified regex format
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {string} regex - The regular expression to check
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const matches = (values, fieldName, regex) => !isBlank(values[fieldName]) && values[fieldName].search(regex) === -1
    ? 'This is not in the correct format'
    : '';
/**
 * Validates that the value is greater than the specified value
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any} limit - The value the field value must be greater than
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const greaterThan = (values, fieldName, limit) => values[fieldName] > limit ? '' : `This value must be greater than ${limit}`;
/**
 * Validates that the value is greater than or equal to the specified value
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any} limit - The value the field value must be greater than or equal to
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const greaterThanOrEqualTo = (values, fieldName, limit) => values[fieldName] >= limit ? '' : `This value must be greater than or equal to ${limit}`;
/**
 * Validates that the value is less than the specified value
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any} limit - The value the field value must be less than
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const lessThan = (values, fieldName, limit) => values[fieldName] < limit ? '' : `This value must be less than ${limit}`;
/**
 * Validates that the value is less than or equal to the specified value
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {any} limit - The value the field value must be less than or equal to
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const lessThanOrEqualTo = (values, fieldName, limit) => values[fieldName] <= limit ? '' : `This value must be less than or equal to ${limit}`;
/**
 * Validates that the value is in an http response
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {string | {path: string, responseBodyArrayProp: string, objectProp?: string}} path - The http api path to call and the response property to look in
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const inHttpResponse = (values, fieldName, args) => __awaiter(this, void 0, void 0, function* () {
    const array = yield callAPIAndGetBodyArray(args);
    return array.indexOf(values[fieldName]) === -1 ? `This is not a valid value` : '';
});
/**
 * Validates that the value is in an http response
 * @param {IFormValues} values - The form field values
 * @param {string} fieldName - The field name to check
 * @param {string | {path: string, responseBodyArrayProp: string, objectProp?: string}} path - The http api path to call and the response property to look in
 * @returns {string} - An empty string (if valid) or the error message (if invalid)
 */
export const notInHttpResponse = (values, fieldName, args) => __awaiter(this, void 0, void 0, function* () {
    const array = yield callAPIAndGetBodyArray(args);
    return array.indexOf(values[fieldName]) > -1 ? `This is not a valid value` : '';
});
const callAPIAndGetBodyArray = (args) => __awaiter(this, void 0, void 0, function* () {
    let path;
    let responseBodyArrayProp = '';
    let objectProp = '';
    if (typeof args === 'string') {
        path = args;
    }
    else {
        path = args.path;
        responseBodyArrayProp = args.responseBodyArrayProp;
        objectProp = args.objectProp;
    }
    const result = yield httpCall({ path });
    let arrWithObjects;
    if (result && result.body) {
        if (responseBodyArrayProp && result.body[responseBodyArrayProp]) {
            arrWithObjects = result.body[responseBodyArrayProp];
        }
        else if (Array.isArray(result.body)) {
            arrWithObjects = result.body;
        }
        else {
            arrWithObjects = [];
        }
    }
    else {
        arrWithObjects = [];
    }
    const array = arrWithObjects.map(item => {
        if (objectProp && item[objectProp]) {
            return item[objectProp];
        }
        else {
            return item;
        }
    });
    return array;
});
