var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { variableReplacer } from '../../shared/dataBinder';
import { httpCall } from '../../shared/http';
import { responseCollectionMapper } from './tag-http.utils';
/* Makes a http request */
export class TagHttp {
    constructor() {
        /**
         * Determines when the http request is made. The request is made when the component loads by default
         * The available events are load, submit, search, pageRequest, click, buttonClick, refresh
         * This prop can take a comma delimited list of event names where multiple events should trigger the request
         */
        this.requestEvents = 'load';
        /** Whether any error messages are output */
        this.displayError = false;
        /**
         * The HTTP headers for the request
         */
        this.requestHeaders = new Headers({
            Accept: 'application/json',
            'Content-Type': 'application/json',
        });
        /**
         * Whether a response mapper function has been attached.
         * This is used to fire the responseMapperAttached event
         */
        this.responseMapperAttached = false;
        this.haveError = false;
        this.calling = false;
    }
    /**
     * Make the http request when the component has loaded if specified
     * Set the method to post if not specified and the request event is onSubmit
     */
    componentDidLoad() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.haveRequestEvent('load')) {
                this.method = this.method || 'get';
                yield this.makeHttpCall({
                    method: this.method,
                    path: this.path,
                });
            }
            else if (this.haveRequestEvent('submit')) {
                this.method = this.method || 'post';
            }
        });
    }
    /**
     * Fire the responseMapperAttached event if a response mapper has just been attached
     */
    componentDidUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.responseMapperAttached && this.responseMapper) {
                this.responseMapperAttached = true;
                if (this.haveRequestEvent('responseMapperAttached')) {
                    this.method = this.method || 'get';
                    yield this.makeHttpCall({
                        method: this.method,
                        path: this.path,
                    });
                }
            }
        });
    }
    /**
     * Adds or sets and existing request HTTP header value
     * @param {string} name - HTTP header name
     * @param {string} value - HTTP header value
     */
    setRequestHeader(name, value) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requestHeaders.append(name, value);
            if (this.haveRequestEvent('headersAdded')) {
                this.method = this.method || 'get';
                yield this.makeHttpCall({
                    method: this.method,
                    path: this.path,
                });
            }
        });
    }
    /**
     * Adds or sets and existing request HTTP header value
     * @param { [key: string]: string } headers - Object literal containing the headers
     */
    setRequestHeaders(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const prop in headers) {
                if (headers.hasOwnProperty(prop)) {
                    this.requestHeaders.append(prop, headers[prop]);
                }
            }
            if (this.haveRequestEvent('headersAdded')) {
                this.method = this.method || 'get';
                yield this.makeHttpCall({
                    method: this.method,
                    path: this.path,
                });
            }
        });
    }
    /**
     * Sets the request body
     * @param {any} body - The request body
     */
    setRequestBody(body) {
        this.requestBody = body;
    }
    /** Makes the http request */
    makeHttpCall(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                args = {
                    body: this.requestBody,
                    headers: this.requestHeaders,
                    method: this.method,
                    path: this.path,
                };
            }
            if (!args.headers) {
                args.headers = this.requestHeaders;
            }
            if (!args.body) {
                args.body = this.requestBody;
            }
            args = this.mapRequest(args);
            this.calling = true;
            const result = yield httpCall(args);
            this.calling = false;
            this.haveError = !result.ok;
            const mappedResponse = this.mapResponse(args, result);
            this.executePostEvents(mappedResponse);
            this.pushResultToChildren(mappedResponse);
        });
    }
    /**
     * Listens to the specified events
     * Note that the path and method in the event args will override this components props
     */
    handleSubmit(e) {
        if (this.haveRequestEvent('submit')) {
            const callArgs = e.detail;
            if (!callArgs.method) {
                callArgs.method = this.method;
            }
            if (!callArgs.path) {
                callArgs.path = this.path;
            }
            this.makeHttpCall(callArgs);
        }
    }
    handleSearch(e) {
        if (this.haveRequestEvent('search')) {
            const search = e.detail.criteria;
            const path = variableReplacer(this.path, {
                search,
                page: '1',
            });
            const callArgs = {
                path,
                method: this.method || 'get',
            };
            this.makeHttpCall(callArgs);
        }
    }
    handlePageRequest(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.haveRequestEvent('pageRequest')) {
                const args = e.detail;
                const path = variableReplacer(this.path, {
                    page: args.page.toString(),
                    search: this.getSearchCriteria(),
                });
                const callArgs = {
                    path,
                    method: this.method || 'get',
                };
                this.makeHttpCall(callArgs);
            }
        });
    }
    handleClick() {
        if (this.haveRequestEvent('click')) {
            const callArgs = {
                method: this.method,
                path: this.path,
            };
            this.makeHttpCall(callArgs);
        }
    }
    handleButtonClick() {
        if (this.haveRequestEvent('buttonClick')) {
            const callArgs = {
                method: this.method,
                path: this.path,
            };
            this.makeHttpCall(callArgs);
        }
    }
    handleGenericEvent(e) {
        const eventName = e.detail.name;
        if (this.haveRequestEvent(eventName)) {
            const callArgs = {
                method: this.method,
                path: this.path,
            };
            this.makeHttpCall(callArgs);
        }
    }
    render() {
        const { displayError, haveError, calling } = this;
        return (h("div", null,
            h("slot", null),
            displayError &&
                haveError && (h("tag-alert", { type: "danger" }, "Sorry, a problem has occurred. Please try again")),
            calling && (h("div", { class: "tag-http__progress-container" },
                h("tag-progress-indeterminate", null)))));
    }
    /** Checks whether the event passed is specified as a request event */
    haveRequestEvent(eventName) {
        if (!this.requestEvents || !eventName) {
            return false;
        }
        else {
            const requestEventsArr = this.requestEvents.split(',');
            let found = false;
            requestEventsArr.forEach(requestEvent => {
                if (requestEvent.toLowerCase() === eventName.toLowerCase()) {
                    found = true;
                }
            });
            return found;
        }
    }
    executePostEvents(response) {
        if (response.ok) {
            if (this.successEventName) {
                this.event.emit({
                    args: response,
                    name: this.successEventName,
                });
            }
        }
        else {
            if (this.failureEventName) {
                this.event.emit({
                    args: response,
                    name: this.failureEventName,
                });
            }
        }
        this.responded.emit(response);
    }
    /** Calls custom function to do any additional mapping for the request */
    mapRequest(args) {
        if (this.requestMapper) {
            const newArgs = this.requestMapper(args);
            return newArgs;
        }
        else {
            return args;
        }
    }
    /** maps the response data */
    mapResponse(request, response) {
        if (this.responseMapper) {
            return this.responseMapper(response);
        }
        else if (request.method === 'get') {
            // if the request is a GET then automatically try to map the body so
            // that it binds nicely to tag-components
            const body = responseCollectionMapper(response);
            if (body) {
                response.body = body;
            }
            return response;
        }
        else {
            return response;
        }
    }
    /**
     * This pushes the http request result down any immediate child component that the relevant methods.
     * For child tag-form components, the IHttpResponse will be pushed to submitComplete() on tag-form.
     * For child data bound components such as tag-search and tag-list, the data in IHttpResponse
     * will be pushed to setData() on the child component
     */
    pushResultToChildren(response) {
        if (this.element.childNodes && this.element.childNodes.length > 0) {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < this.element.childNodes.length; i++) {
                const child = this.element.childNodes[i];
                if (this.haveRequestEvent('submit')) {
                    if (child.submitComplete) {
                        child.submitComplete(response);
                    }
                }
                if (child.setData) {
                    child.setData(response.body);
                }
                else if (child.children && child.children.length > 0) {
                    // for compatibility reasons, we need to check the children if setData is not found
                    // due to some browsers not having setData() at the child level due to the shady dom
                    for (const subChild of child.children) {
                        if (subChild.setData) {
                            subChild.setData(response.body);
                        }
                    }
                }
            }
        }
    }
    getSearchCriteria() {
        const searchElement = this.element.querySelector('tag-search');
        if (searchElement) {
            return searchElement.getSearch ? searchElement.getSearch() : '';
        }
        else {
            return '';
        }
    }
    static get is() { return "tag-http"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "calling": {
            "state": true
        },
        "displayError": {
            "type": Boolean,
            "attr": "display-error"
        },
        "element": {
            "elementRef": true
        },
        "failureEventName": {
            "type": String,
            "attr": "failure-event-name"
        },
        "haveError": {
            "state": true
        },
        "makeHttpCall": {
            "method": true
        },
        "method": {
            "type": String,
            "attr": "method",
            "mutable": true
        },
        "path": {
            "type": String,
            "attr": "path"
        },
        "requestEvents": {
            "type": String,
            "attr": "request-events"
        },
        "requestMapper": {
            "type": "Any",
            "attr": "request-mapper"
        },
        "responseMapper": {
            "type": "Any",
            "attr": "response-mapper"
        },
        "setRequestBody": {
            "method": true
        },
        "setRequestHeader": {
            "method": true
        },
        "setRequestHeaders": {
            "method": true
        },
        "successEventName": {
            "type": String,
            "attr": "success-event-name"
        }
    }; }
    static get events() { return [{
            "name": "event",
            "method": "event",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "responded",
            "method": "responded",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get listeners() { return [{
            "name": "submit",
            "method": "handleSubmit"
        }, {
            "name": "search",
            "method": "handleSearch"
        }, {
            "name": "pageRequest",
            "method": "handlePageRequest"
        }, {
            "name": "click",
            "method": "handleClick"
        }, {
            "name": "buttonClick",
            "method": "handleButtonClick"
        }, {
            "name": "event",
            "method": "handleGenericEvent"
        }]; }
    static get style() { return "/**style-placeholder:tag-http:**/"; }
}
